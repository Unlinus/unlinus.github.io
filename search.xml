<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ESXi6.7一些罕见问题的解决方法</title>
    <url>/2020/04/27/ESXi%E4%B8%80%E4%BA%9B%E7%BD%95%E8%A7%81%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>一大早睡得正香，突然被一通电话叫醒了（内心<del>万马奔腾</del>一万个不情愿）。“…昨晚停了一次电，服务器全都连不上了，网络有问题，过来帮忙看一下”。点开微信群一看，瞬间不淡定了：“工程师反映，系统远程不了了，网站也打不开”，“停电了，昨晚半夜供电局高压跳闸，我们的电池没能坚持下去”。这不意味着整个机房瞬间失去电力供应了？！</p>
<p>我连滚带爬坐到了电脑椅上，打开电脑，还能连接到机房VPN，说明出口网络还是通的。几经排查，原来是因为刀片服务器的交换机忘记保存配置，断电重启后部分配置失效了（一记耳光）。</p>
<h1 id="第一个问题：VCSA无法访问"><a href="#第一个问题：VCSA无法访问" class="headerlink" title="第一个问题：VCSA无法访问"></a>第一个问题：VCSA无法访问</h1><h2 id="异常表现"><a href="#异常表现" class="headerlink" title="异常表现"></a>异常表现</h2><p>排查过程中发现，VCSA访问不了了，提示<strong>503 Service Unavailable(Failed to connect to endpoint…）</strong>。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>第一反应告诉我，可能是VCSA的核心服务没能启动。按照网上大神的说法，需要SSH登录到VCSA，用命令行来启动核心服务。但是问题来了，这VCSA默认没打开SSH服务啊，还能怎么搞？<br>其实VCSA还有个设备管理功能（用于进行VCSA底层组件管理），可以通过浏览器访问<code>https://&lt;VCSA IP&gt;:5480：</code>进入：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-04-29-23-20-11.png" alt="2020-04-29-23-20-11"></p>
<p><img src="https://cdn.unlinus.cn/hexo-images/2020-04-29-23-23-46.png" alt="2020-04-29-23-23-46"></p>
<p>果不其然，VCSA的好几个核心服务都没有启动。按照下图说明来启动相关服务，然后看看VCSA是不是能访问了？：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-04-29-23-30-14.png" alt="2020-04-29-23-30-14"></p>
<p><img src="https://cdn.unlinus.cn/hexo-images/2020-04-29-23-32-31.png" alt="2020-04-29-23-32-31"></p>
<h1 id="第二个问题：无法操作虚拟机"><a href="#第二个问题：无法操作虚拟机" class="headerlink" title="第二个问题：无法操作虚拟机"></a>第二个问题：无法操作虚拟机</h1><h2 id="异常表现-1"><a href="#异常表现-1" class="headerlink" title="异常表现"></a>异常表现</h2><p>一切尽在不言中：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-04-29-23-35-50.png" alt="2020-04-29-23-35-50"></p>
<p>还有无脑弹出的消息：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-04-29-23-37-05.png" alt="2020-04-29-23-37-05"></p>
<h2 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h2><p>同第一个问题一样，也是因VCSA服务异常造成的。把相关服务启动或者重新启动一遍就可以了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通常遇到以上问题时，重点关注这个几个服务的状态，如果处于异常或停止状态，只需把对应服务启动或重启就OK了：</p>
<ul>
<li>VMware vService Manager</li>
<li>VMware vSphere Update Manager</li>
<li>VMware PSC Health</li>
<li>VMware vSphere Client</li>
<li>VMware vSphere Web Client</li>
<li>VMware vCenter Server</li>
<li>VMware vCenter-Services</li>
</ul>
<p>数据无价，双手合十，祈祷永不宕机，永不断电。</p>
]]></content>
      <categories>
        <category>搬砖随记</category>
        <category>vSphere</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>vSphere</tag>
        <tag>故障</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>ESXi升级方法 - 从5.5到6.0</title>
    <url>/2020/04/26/ESXi%E4%BB%8E5.5%E5%88%B06.0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上个月给数据中心的vSphere平台做了一次升级，期间遇到各种各样的坑，还好后期都完美解决了，不然真得跑路了（都是自找的= =）。现在我来把当时的整个操作流程整理一下。</p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>先简单介绍一下这套vSphere平台的配置。平台共包含10个计算节点，均已组成集群并配置了HA，集群使用IPSAN共享存储，每个计算节点正在运行的ESXi版本是5.1。现在的任务是将每个节点的ESXi版本都升级到5.5。</p>
<p>那么问题来了，怎样才能保证ESXi能够平滑升级的同时，又不影响到平台上的虚拟机呢？这时，我们可以利用集群的特性，将需要升级的节点上的虚拟机热迁移到其他节点（热迁移需要配置vMotion），然后将这个节点切换到维护模式，再进行升级。这样既能完成升级，又能保证业务不中断，岂不美哉！</p>
<h1 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>前面balabala了一堆废话，是时候开始实操了！我们先准备好一些东西：</p>
<ol>
<li>超级终端软件（如PuTTY、SecureCRT、XShell、MobaXTerm等，Win10 CMD自带的SSH功能也是可以的）；</li>
<li>ESXi 5.5升级包（可从VMware官网或其他途径获取）</li>
<li>VMware vSphere Client（vSphere客户端）</li>
</ol>
<h2 id="通过vSphere-Client进行操作"><a href="#通过vSphere-Client进行操作" class="headerlink" title="通过vSphere Client进行操作"></a>通过vSphere Client进行操作</h2><p>使用vSphere Client登录到ESXi节点，将节点切换到维护模式：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-04-26-18-00-29.png" alt="2020-04-26-18-00-29"></p>
<p><img src="https://cdn.unlinus.cn/hexo-images/2020-04-26-18-04-01.png" alt="2020-04-26-18-04-01"></p>
<p>将ESXi升级包上传到数据存储，并记下数据存储路径，后续升级操作要用到。例如我这里将升级包上传到了本地存储，那么我现在得记下本地存储的路径：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-04-26-18-20-10.png" alt="2020-04-26-18-20-10"></p>
<h2 id="通过SSH登录到ESXi节点"><a href="#通过SSH登录到ESXi节点" class="headerlink" title="通过SSH登录到ESXi节点"></a>通过SSH登录到ESXi节点</h2><p>打开该节点的配置→安全配置文件，启动SSH服务：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-04-26-18-05-41.png" alt="2020-04-26-18-05-41"></p>
<p><img src="https://cdn.unlinus.cn/hexo-images/2020-04-26-18-06-45.png" alt="2020-04-26-18-06-45"></p>
<p>打开超级终端软件（笔者用的是XShell），使用ESXi的账号密码，用SSH登录到ESXi节点：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-04-26-18-09-19.png" alt="2020-04-26-18-09-19"></p>
<h2 id="使用命令对ESXi进行平滑升级"><a href="#使用命令对ESXi进行平滑升级" class="headerlink" title="使用命令对ESXi进行平滑升级"></a>使用命令对ESXi进行平滑升级</h2><p>使用这条命令列出ESXi升级包的版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">esxcli software sources profile list -d &lt;ESXi升级包所在的数据存储的路径&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.unlinus.cn/hexo-images/2020-04-26-18-15-43.png" alt="2020-04-26-18-15-43"><br>（注：数据存储路径见本文3.2）</p>
<p>然后使用这条命令，通过升级包进行升级</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">esxcli software profile update -d &lt;ESXi升级包所在的数据存储的路径&gt; -p &lt;ESXi升级包版本&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.unlinus.cn/hexo-images/2020-04-26-19-32-24.png" alt="2020-04-26-19-32-24"><br>稍等片刻会出现升级结果。升级成功后，要求重新启动，这时输入reboot命令，将该节点重启即可。</p>
<h2 id="后续操作"><a href="#后续操作" class="headerlink" title="后续操作"></a>后续操作</h2><p>重启完成后，再次用vSphere Client登录到ESXi，看看ESXi的版本是不是升级到5.5了？<br><img src="https://cdn.unlinus.cn/hexo-images/2020-04-26-19-40-10.png" alt="2020-04-26-19-40-10"></p>
<p>确认升级成功后，将ESXi节点退出维护模式：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-04-26-19-44-17.png" alt="2020-04-26-19-44-17"></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>以上就是ESXi的平滑升级流程。当然，在生产环境下，系统升级前必须拟定相应的方案（例如升级流程、应急预案等），并对原系统进行测试、数据备份，升级过程中必须严格遵循操作规程，升级后还需要保留一定时长的观察期，当这一系列流程都顺利完成后，才能正式交付使用。</p>
]]></content>
      <categories>
        <category>搬砖随记</category>
        <category>vSphere</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>vSphere</tag>
        <tag>虚拟化</tag>
        <tag>升级</tag>
      </tags>
  </entry>
  <entry>
    <title>FusionAccess系列（一）：最小化部署FusionAccess实验环境</title>
    <url>/2020/05/18/FusionAccess%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%9C%80%E5%B0%8F%E5%8C%96%E9%83%A8%E7%BD%B2FusionAccess%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在备考云ip的内容，恰好需要部署一套环境来满足学习需要。下面将介绍FusionAccess桌面云实验环境的搭建过程。<br>在开始之前，先简单介绍下华为的FusionAccess（卖了个广告）。“华为云™FusionAccess桌面云解决方案是基于华为FusionSphere的一种虚拟桌面应用，通过在云平台上部署软、硬件，使终端用户通过瘦客户端或者其他任何与网络相连的设备来访问跨平台的应用程序，以及整个客户桌面。”</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><div class="note warning flat"><p><strong>注意</strong>：<br>本文的实验是基于上一篇文章中的FusionCompute基础环境<a href="https://www.unlinus.cn/2020/05/13/%E4%BD%BF%E7%94%A8CentOS%208%20Cockpit+KVM%E6%90%AD%E5%BB%BAFusionCompute%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83/">[传送门]</a>来进行的。由于篇幅有限，故不再过多介绍FusionCompute的搭建步骤。</p>
</div>

<h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><table>
<thead>
<tr>
<th>文件名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>FusionAccess_Manager_Installer_6.5.0.iso</td>
<td>FusionAccess基础架构节点安装镜像</td>
</tr>
<tr>
<td>FusionAccess_WindowsDesktop_Installer_6.5.0.iso</td>
<td>Windows配套软件包镜像</td>
</tr>
</tbody></table>
<h2 id="节点、网络规划"><a href="#节点、网络规划" class="headerlink" title="节点、网络规划"></a>节点、网络规划</h2><p>所有节点均部署在同一个局域网内（局域网内必须关闭DHCP！）。硬件设备和上一期文章一样，都是一台破笔记本+老台式机。考虑到FusionAccess疯狂吃内存的特（兽）性（行），特地给台式机加多了一条4G内存（内存还是从我姐电脑上抠下来的= =）。</p>
<table>
<thead>
<tr>
<th>节点名称</th>
<th>节点类型</th>
<th>IP地址</th>
<th>默认网关</th>
</tr>
</thead>
<tbody><tr>
<td>CNA</td>
<td>计算节点代理</td>
<td>10.6.0.50/24</td>
<td>10.6.0.254</td>
</tr>
<tr>
<td>VRM</td>
<td>虚拟化资源管理</td>
<td>10.6.0.60/24</td>
<td>10.6.0.254</td>
</tr>
<tr>
<td>ITA-HDC-WI</td>
<td>桌面云基础架构节点</td>
<td>10.6.0.70/24</td>
<td>10.6.0.254</td>
</tr>
<tr>
<td>AD&amp;DNS&amp;DHCP</td>
<td>AD&amp;DNS&amp;DHCP</td>
<td>10.6.0.80/24</td>
<td>10.6.0.254</td>
</tr>
</tbody></table>
<h1 id="部署AD、DNS、DHCP服务器："><a href="#部署AD、DNS、DHCP服务器：" class="headerlink" title="部署AD、DNS、DHCP服务器："></a>部署AD、DNS、DHCP服务器：</h1><p>使用VMware Workstation创建一台虚拟机，并安装好<strong>Windows Server 2012 R2 DataCenter</strong>操作系统。配置好网络、主机名，然后将系统重启：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-18-52-26.png" alt="2020-05-18-18-52-26"><br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-18-48-55.png" alt="2020-05-18-18-48-55"></p>
<p>打开服务器管理器，添加角色和服务，选择Active Directory域服务、DNS服务器、DHCP服务器这三个角色：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-19-22-15.png" alt="2020-05-18-19-22-15"></p>
<p>一直点击下一步，直至开始安装（勾选自动重新启动目标服务器）：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-19-23-54.png" alt="2020-05-18-19-23-54"></p>
<h2 id="配置域服务、域用户等信息"><a href="#配置域服务、域用户等信息" class="headerlink" title="配置域服务、域用户等信息"></a>配置域服务、域用户等信息</h2><h3 id="域控制器安装"><a href="#域控制器安装" class="headerlink" title="域控制器安装"></a>域控制器安装</h3><p>安装完成后，开始配置域。点击“将此服务器提升为域控制器”：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-19-41-47.png" alt="2020-05-18-19-41-47"></p>
<p>添加新林，域名称自定义（需符合域名格式）。分别配置DSRM密码、NetBIOS域名、文件保存位置等参数（基本上保持默认、点击下一步即可）<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-19-43-13.png" alt="2020-05-18-19-43-13"><br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-19-44-39.png" alt="2020-05-18-19-44-39"><br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-19-46-59.png" alt="2020-05-18-19-46-59"><br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-19-47-27.png" alt="2020-05-18-19-47-27"><br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-19-48-40.png" alt="2020-05-18-19-48-40"></p>
<p>检查配置是否正确，确认无误后开始安装域控制器。安装完成后会自动重启：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-19-50-18.png" alt="2020-05-18-19-50-18"><br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-19-50-42.png" alt="2020-05-18-19-50-42"></p>
<h3 id="域管理员账户配置"><a href="#域管理员账户配置" class="headerlink" title="域管理员账户配置"></a>域管理员账户配置</h3><p>打开Active Directory用户和计算机，新建组织单位（OU）：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-20-15-35.png" alt="2020-05-18-20-15-35"><br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-20-16-09.png" alt="2020-05-18-20-16-09"></p>
<p>右键单击该OU，新建用户vdsadmin，用于后期与FusionAccess进行对接：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-20-18-10.png" alt="2020-05-18-20-18-10"><br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-20-19-01.png" alt="2020-05-18-20-19-01"></p>
<p>将vdsadmin用户设为委派控制用户，如下图操作：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-20-25-42.png" alt="2020-05-18-20-25-42"><br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-20-26-58.png" alt="2020-05-18-20-26-58"><br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-20-27-51.png" alt="2020-05-18-20-27-51"></p>
<p>设置该委派控制用户的任务，选中“创建自定义任务去委派”，单击“下一步”：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-20-29-13.png" alt="2020-05-18-20-29-13"></p>
<p>选中“这个文件夹，这个文件夹中的对象，以及创建在这个文件夹中的新对象”，单击“下一步”：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-20-29-43.png" alt="2020-05-18-20-29-43"></p>
<p>选中“特定子对象的创建/删除”，在“权限”区域，选择“创建 计算机 对象”和“删除 计算机 对象”，单击“下一步”：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-20-33-03.png" alt="2020-05-18-20-33-03"></p>
<h3 id="配置备份路径和远程协助："><a href="#配置备份路径和远程协助：" class="headerlink" title="配置备份路径和远程协助："></a>配置备份路径和远程协助：</h3><p>将Windows配套软件包镜像<code>FusionAccess_WindowsDesktop_Installer_6.5.0.iso</code>挂载给该虚拟机。虚拟机内打开光驱，运行run.bat，点击扩展部署，安装Windwos备份工具：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-20-43-56.png" alt="2020-05-18-20-43-56"><br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-20-44-49.png" alt="2020-05-18-20-44-49"></p>
<p>配置备份文件路径（不能设置在系统盘所在目录），保存并退出即可：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-21-02-24.png" alt="2020-05-18-21-02-24"></p>
<h2 id="配置DNS服务"><a href="#配置DNS服务" class="headerlink" title="配置DNS服务"></a>配置DNS服务</h2><h3 id="配置反向解析"><a href="#配置反向解析" class="headerlink" title="配置反向解析"></a>配置反向解析</h3><p>打开DNS管理器，右键单击反向查找区域，新建一个反向查找区域：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-22-25-18.png" alt="2020-05-18-22-25-18"></p>
<p>保持默认配置，一直点击下一步到此处，配置网络ID（网络地址）：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-22-27-11.png" alt="2020-05-18-22-27-11"></p>
<h3 id="配置正向解析"><a href="#配置正向解析" class="headerlink" title="配置正向解析"></a>配置正向解析</h3><p>展开正向查找区域，右键单击域名，添加一个主机记录（用于解析HDC）：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-22-31-31.png" alt="2020-05-18-22-31-31"></p>
<p>配置二级域名及其对应的IP地址（FusionAccess节点IP），<strong>并创建相关的指针记录</strong>：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-22-33-53.png" alt="2020-05-18-22-33-53"></p>
<p>查看添加的记录：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-22-41-51.png" alt="2020-05-18-22-41-51"></p>
<h3 id="配置DNS服务器属性"><a href="#配置DNS服务器属性" class="headerlink" title="配置DNS服务器属性"></a>配置DNS服务器属性</h3><p>仅侦听本机IP地址：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-22-47-45.png" alt="2020-05-18-22-47-45"></p>
<p>配置转发器（用于迭代查询，云主机需要访问外网时必须设置）<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-23-29-51.png" alt="2020-05-18-23-29-51"></p>
<p>配置服务器选项（选配，如果云主机无需访问外网，需要禁用递归）<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-23-02-29.png" alt="2020-05-18-23-02-29"></p>
<p>删除所有根域：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-23-03-33.png" alt="2020-05-18-23-03-33"></p>
<p>右键单击主机名，配置DNS老化和清理功能：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-23-05-25.png" alt="2020-05-18-23-05-25"><br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-23-05-57.png" alt="2020-05-18-23-05-57"><br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-23-06-20.png" alt="2020-05-18-23-06-20"></p>
<p>关闭IPv6协议：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-23-10-49.png" alt="2020-05-18-23-10-49"></p>
<p>在CMD输入以下命令，关闭隧道适配器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netsh interface teredo set state disabled</span><br><span class="line">netsh interface 6to4 set state disabled</span><br><span class="line">netsh interface isatap set state disabled</span><br></pre></td></tr></table></figure>

<h2 id="配置DHCP服务"><a href="#配置DHCP服务" class="headerlink" title="配置DHCP服务"></a>配置DHCP服务</h2><p>打开DHCP服务管理器，右键单击主机名，添加授权：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-23-20-48.png" alt="2020-05-18-23-20-48"></p>
<p>新建一个作用域，输入作用域名称、起始和结束IP地址、<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-23-19-37.png" alt="2020-05-18-23-19-37"><br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-23-22-10.png" alt="2020-05-18-23-22-10"><br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-23-22-33.png" alt="2020-05-18-23-22-33"><br>（DHCP排除、租期等选项可以不用设置）</p>
<p>配置路由、DNS等选项（其余配置保持默认即可），激活作用域：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-23-24-05.png" alt="2020-05-18-23-24-05"><br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-23-24-40.png" alt="2020-05-18-23-24-40"><br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-23-26-14.png" alt="2020-05-18-23-26-14"><br>（注：首选分配的DNS必须是域服务器的IP地址！）</p>
<h1 id="部署FusionAccess基础架构节点："><a href="#部署FusionAccess基础架构节点：" class="headerlink" title="部署FusionAccess基础架构节点："></a>部署FusionAccess基础架构节点：</h1><div class="note warning flat"><p><strong>注意</strong>:<br>FusionAccess基础架构虚拟机，要求vCPU至少4个，内存至少12GB，磁盘至少40GB！</p>
</div>

<p>使用VMware Workstation创建一台虚拟机，并挂载基础架构服务器安装镜像，作为FusionAccess基础架构服务器。打开虚拟机电源进行安装：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-17-51-10.png" alt="2020-05-18-17-51-10"></p>
<p>配置节点网络、主机名、root密码等参数（和VRM的安装部署步骤基本一致），开始安装：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-17-54-27.png" alt="2020-05-18-17-54-27"><br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-17-56-00.png" alt="2020-05-18-17-56-00"><br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-17-55-47.png" alt="2020-05-18-17-55-47"><br>安装完成后将自动重启。</p>
<h2 id="初始化ITA、GaussDB、HDC、WI、License等基础组件"><a href="#初始化ITA、GaussDB、HDC、WI、License等基础组件" class="headerlink" title="初始化ITA、GaussDB、HDC、WI、License等基础组件"></a>初始化ITA、GaussDB、HDC、WI、License等基础组件</h2><div class="note info flat"><p><strong>提示：</strong><br>本教程中，FusionAccess的基础组件如ITA、WI、HDC、GaussDB等，均部署在该节点内（All in one）.</p>
</div>
<p>在命令行界面，使用root账号密码登录到ITA，开始部署FusionAccess基础组件（如果未出现FusionAccess界面，输入startTools运行即可）：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-20-57-44.png" alt="2020-05-18-20-57-44"></p>
<p>按照下图依次选择（图示为All in one安装步骤）：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-21-05-32.png" alt="2020-05-18-21-05-32"><br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-21-09-06.png" alt="2020-05-18-21-09-06"></p>
<p>输入本节点的IP地址，确认无误后回车，开始初始化组件：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-21-09-29.png" alt="2020-05-18-21-09-29"><br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-21-10-29.png" alt="2020-05-18-21-10-29"></p>
<h2 id="初步配置ITA"><a href="#初步配置ITA" class="headerlink" title="初步配置ITA"></a>初步配置ITA</h2><p>初始化完成后，使用浏览器访问<code>https://&lt;ITA节点IP&gt;:8448</code>登录FusionAccess管理后台:（默认用户名为<em>admin</em>，密码为*Cloud2#$*）：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-21-22-19.png" alt="2020-05-18-21-22-19"></p>
<p>初次登录需要修改默认密码：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-21-23-53.png" alt="2020-05-18-21-23-53"></p>
<p>对接FusionCompute平台，输入VRM节点的IP地址，以及用于对接FusionAccess的用户名和密码，点击下一步（默认用户为<em>vdisysman</em>，密码为<em>VdiEnginE@234</em>）：</p>
<p><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-21-31-40.png" alt="2020-05-18-21-31-40"></p>
<p>对接域服务器，输入域名称、域管理员账号、域服务器IP等信息，点击下一步：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-21-37-37.png" alt="2020-05-18-21-37-37"></p>
<div class="note danger flat"><p><strong>小坑：</strong><br>一定要保证所有节点之间的时间同步（或时间跳变不超过3min）！否则会影响服务运行，如图：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-21-55-40.png" alt="2020-05-18-21-55-40"></p>
<p>使用命令修改系统日期，并将日期写入BIOS(注意格式)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">date -s &quot;2020-05-18 22:05:00&quot;</span><br><span class="line">hwclock -w</span><br></pre></td></tr></table></figure></div>

<p>其余配置保持默认即可，一直点击下一步：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-22-10-22.png" alt="2020-05-18-22-10-22"><br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-22-10-39.png" alt="2020-05-18-22-10-39"></p>
<p>检查配置无误后，点击提交：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-22-12-01.png" alt="2020-05-18-22-12-01"></p>
<p>配置完成：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-18-22-39-12.png" alt="2020-05-18-22-39-12"></p>
<h1 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h1><p>以上内容只介绍了一个最基本、最小化的FusionAccess环境搭建过程。后续我会继续补充桌面云管理平台的使用教程。</p>
]]></content>
      <categories>
        <category>搬砖随记</category>
        <category>Linux</category>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>虚拟化</tag>
        <tag>桌面云</tag>
        <tag>华为</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo折腾手记</title>
    <url>/2020/04/24/Hexo%E6%8A%98%E8%85%BE%E6%89%8B%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="写在最前面…"><a href="#写在最前面…" class="headerlink" title="写在最前面…"></a>写在最前面…</h1><p>Hexo是基于node.js构建的一套静态博客平台，安装部署过程都比较简单，稍微懂一点点html和Markdown语法就能搞定（这也是笔者由WP转向Hexo的一个初衷…）<br>话不多说，立马开搞！</p>
<h2 id="步骤记录（笔者用的是Windows）"><a href="#步骤记录（笔者用的是Windows）" class="headerlink" title="步骤记录（笔者用的是Windows）"></a>步骤记录（笔者用的是Windows）</h2><h2 id="开始之前…"><a href="#开始之前…" class="headerlink" title="开始之前…"></a>开始之前…</h2><p>万事开头难（特别是对于我这种对编程一窍不通的菜鸡儿= =）。要让Hexo跑起来，首先要满足一些条件：</p>
<ol>
<li>一台Windows或Linux主机；</li>
<li>主机内部署好node.js环境；</li>
<li>安装好Git（用于将hexo项目pull到本地，玩码云或者Gayhub的同志必备）；</li>
<li>最基本的！必须懂得npm的简单使用！必须得会一点Markdown语法（除非你拿这玩意当记事本来写）；</li>
<li>准备好编辑器（sublime，atom，vscode，typora等等）。<h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2>下载地址：<a href="http://npm.taobao.org/mirrors/git-for-windows/" title="http://npm.taobao.org/mirrors/git-for-windows/">http://npm.taobao.org/mirrors/git-for-windows/</a>。我下的是最新版：<br><img src="https://cdn.unlinus.cn/hexo-images/npm.png" alt="20200425192102"></li>
</ol>
<p>下载完成后，运行安装（保持默认配置,一直Next即可）。</p>
<h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><p>上<a href="https://nodejs.org/en/">node.js官网</a>下载适合自己系统版本的node.js运行环境安装包（建议用IDM、迅雷之类的工具来下载，这样比较快）。下载完成后，运行安装即可（没什么需要的话，保留默认配置安装就可以了）：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-04-26-20-34-19.png" alt="2020-04-26-20-34-19"></p>
<p>安装完成后,执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node -v      /*查看当前安装的node.js版本*/</span><br><span class="line">v12.16.1</span><br><span class="line">npm -v      /*查看当前安装的node.js软件包管理器版本*/</span><br><span class="line">v6.13.4</span><br><span class="line">npm config set registry http://registry.npm.taobao.org/   /*更换npm安装源为国内源（这里用淘宝的）*/</span><br><span class="line">npm update      /*刷新npm源*/</span><br></pre></td></tr></table></figure>
<h2 id="开始部署Hexo"><a href="#开始部署Hexo" class="headerlink" title="开始部署Hexo"></a>开始部署Hexo</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g      /*使用npm安装Hexo*/</span><br><span class="line">cd /d D:\Project\hexo        /*进入你要部署Hexo的目标文件夹*/</span><br><span class="line">hexo init      /*部署Hexo*/</span><br></pre></td></tr></table></figure>
<p>Tips：Hexo init时，需要将github上的Hexo项目pull下来，速度会比较慢，除非你有喝酸酸乳（/手动滑稽）。初次部署完成后，执行以下命令进行初始化：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean     /*清除缓存*/</span><br><span class="line">hexo g         /*生成静态页面*/</span><br><span class="line">hexo s         /*开始跑Hexo*/</span><br></pre></td></tr></table></figure>

<p>打开浏览器，输入<code>IP地址:4000</code>(本地的话是 <code>localhost:4000</code> 或 <code>127.0.0.1:4000</code>),就可以看到效果了，是不是很简单！<br><img src="https://cdn.unlinus.cn/hexo-images/example.png" alt="20200425192452"></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>如果你没有公网服务器和域名，也可以将你的Hexo丢到Gayhub、码云或者coding之类的代码托管平台上，直接用你的gayhub域名就能访问了！具体步骤可以参考以下链接的内容：</p>
<ol>
<li><a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%88%9D%E6%AC%A1%E8%BF%90%E8%A1%8C-Git-%E5%89%8D%E7%9A%84%E9%85%8D%E7%BD%AE" title="https://git-scm.com/book/zh/v2/起步-初次运行-Git-前的配置">初次运行Git前的配置</a></li>
<li><a href="https://www.jianshu.com/p/e70b4ca63115" title="https://www.jianshu.com/p/e70b4ca63115">hexo博客部署到github</a></li>
</ol>
]]></content>
      <categories>
        <category>博客</category>
        <category>Hexo</category>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>P0-我的Linux之路</title>
    <url>/2021/03/26/P0-%E6%88%91%E7%9A%84Linux%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>掐指一算，接触Linux差不多有3年时间了，说不上精通，但也不能说对它感到陌生。回过头来细想了一下，似乎还没有针对Linux进行过系统化的学习。<br>So，这是我第一篇正经的Linux笔记。（水文章の警告/滑稽）</p>
<h1 id="先闻其名"><a href="#先闻其名" class="headerlink" title="先闻其名"></a>先闻其名</h1><p>第一次听说Linux这五个字母，是在我读初一的时候。<br>我姐大学毕业以后，寄回了一箱子的书。有一天我在收拾房间的时候，看到了这破箱子。我寻思，这箱子里会不会找到一些有意思的东西？然后便开始疯狂搜刮（老毛病了哈哈），找到了这本东西：<br><img src="https://cdn.unlinus.cn/hexo-images/2021-03-26-15-08-51.jpg" alt="2021-03-26-15-08-51"><br>（这书几乎改变了我未来的发展方向。从我读初中开始，到高中毕业，都会时不时拿出来翻）<br>某天在看着书的时候，偶然翻到了Linux部分。这部分对Linux的叙述，用了2页左右的文字，和几张平平无奇的黑白配图。后来专门去百度搜了一下Linux，除了知道Linux的作者是Linus、Linux是开源的以外，其他的感觉没什么吸引力，就没再继续研究。</p>
<h1 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h1><p>读初二的时候，我认识了同桌，就叫他小威吧。他当时给我的印象是：啥都懂，经常聊到计算机这些东西（他说的什么黑苹果，IOS，我当时都不知道是什么玩意/尴尬），而且他还是个重度游戏玩家。有一次在跟他聊的时候，他提到了Linux——没错，就是如今大名鼎鼎的Linux发行版Ubuntu。不同的是，他所描述的Linux，有着比Windows更炫酷的图形界面，跟我书上看到的Linux截然不同。于是，我决定拿家里的破电脑试试。当时，家里电脑配置还是老掉牙的奔腾4+512MB内存，硬盘空间也只有可怜的80G（还是IDE接口的），安装Ubuntu可是一个不小的挑战。加上我当时还不太会重装系统，所以搁了很长时间都没去弄。</p>
<p>终于有一天，恰逢周末，又没什么作业，总算可以开搞了。我去Ubuntu官网下了一个wubi程序（Ubuntu在Windows下的一个辅助安装工具），然后花了半天时间一边百度，一边给硬盘分区，总算腾出了20G左右的空间来安装Ubuntu。设置好分区和用户名密码后，开始安装，然后安装又花了大半天时间，中途还失败了好多次。安装完重启后，终于如愿以偿看到了Linux的真容。这界面着实令我眼前一亮（当时没截图，随便在网上找了个同款的）：<br><img src="https://cdn.unlinus.cn/hexo-images/2021-03-26-16-48-44.png" alt="2021-03-26-16-48-44"><br>然而好看归好看，后面操作的时候我懵了，怎么没网？还有，为啥这么卡！我点文件管理器，鼠标一直转圈圈。我点关机，然后系统硬是愣了半天。</p>
<p>好吧我决定放弃了，然而接下来的事情才是最可怕的（搞不好等会又得招来一顿臭骂）。重启以后，系统默认进入了Ubuntu，Windows XP哪去了？后来又重启了一次，发现有个GRUB系统选单，Windows XP排在了最底下。我想，这菜单应该是可以改的，把Windows移到第一位不就好了？于是又去百度找修改方法，还把命令写了下来…于是就有了这张图：<br><img src="https://cdn.unlinus.cn/hexo-images/2021-03-26-17-09-58.jpg" alt="2021-03-26-17-09-58"><br>一顿操作猛如虎，到最后还是没能修改成功。无奈之下，只好把Ubuntu删掉了（步骤不太记得了，反正删也是删了老半天）。后来，我和小威聊的时候，他聊到了另一款Linux发行版Elementary OS（Ubuntu衍生版）。我又去试了一遍，然后再次以相同的结果告终，还差点把原系统给干掉。从那以后，我再也不想碰Linux了。</p>
<h1 id="四年后"><a href="#四年后" class="headerlink" title="四年后"></a>四年后</h1><p>时间来到2017年，我读大一，选的专业是计算机网络。一次上课的时候，老师提到了Linux在服务器领域的应用，这让我想起了n年前的Linux经历。当时想了一下嗯，或许后面需要用到。于是，中午下课回到宿舍以后，我找了一个师兄分享的Linux镜像，拿到虚拟机上去装。安装过程都比较顺利，没过多久就安装成功了。然而我当看到黑屏白字的界面以后，心里犯嘀咕了：这他喵是Linux么，图形界面呢？后来去百度查了一下，原来是安装时勾选了最小化安装，默认不包含GUI组件，得手动安装。于是又开始百度百度，总算找到了安装GUI的命令。当时虚拟机还不是很会用，而且因为校园网的原因，虚拟网卡不能直接用桥接，所以虚拟网卡也折腾了很久。终于可以开始安装GUI了，我在虚拟机控制台上，一字一句地输入了这条命令（猜我用的是哪个Linux发行版/滑稽）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum groupinstall -y <span class="string">&quot;GNOME Desktop&quot;</span></span><br></pre></td></tr></table></figure>
<p>然而网速似乎不给力，下载过程非常慢。考虑到下午还得上课，于是我决定让电脑开着，然后爬上床睡觉去了。一觉醒来，发现安装并没有成功。又白忙活了……后来因为没时间，索性把虚拟机删了。就这样，Linux又一次被我抛弃了。</p>
<h1 id="再度拥抱"><a href="#再度拥抱" class="headerlink" title="再度拥抱"></a>再度拥抱</h1><p>2018年，也就是大一下学期，我加入了本专业的工作室，从此打开了新世界的大门。一段时间以后，我发现自己对服务器部署、维护方面比较擅长，便决意往服务器领域去发展。我当时拿来练手的服务器是PowerEdge 2900——工作室最老、最吵、且唯一的一台服务器。奈何噪音实在太难顶（散热风扇可以比得上一台小型的涡轮发动机了），没玩多久就被我扔一边了。后来在师兄和值班老师的帮助下，我拿到了两台相对比较安静的服务器（没错又是PowerEdge 2900），终于可以大展身手了。<br><img src="https://cdn.unlinus.cn/hexo-images/2021-03-26-21-58-57.jpg" alt="2021-03-26-21-58-57"><br>机子刚到手的时候，我还是老样子，给他们装的Windows Server系统。有一天，我在网上看到了VMware ESXi，感觉这东西有点意思，就把服务器换成了ESXi。朋友告诉我，这玩意好像是做云计算用的。本来还想继续研究一番，临近暑假，工作室得断电，只好暂时跟服务器们道别了。一天，我在整理工作室资料的时候，看到了几份神秘的文件。我好奇地打开看了一下，原来是工作室私有云平台的部署文档。同时，还有一张配图，在我当时看起来相当的震撼：<br><img src="https://cdn.unlinus.cn/hexo-images/2021-03-26-22-56-00.jpg" alt="2021-03-26-22-56-00"></p>
<p>我想把这个平台重新维护起来，于是我联系上了大师兄。然而答复比较令人失望，平台在工作室分家的时候已经全部拆解了。我决定从零开始部署这套平台。然而痛苦才刚刚开始。当时学习的是CentOS+OpenStack，本来看视频已经学得糊里糊涂了，加上没有Linux基础，学起来相当难受，简直就是摸滚带爬。过了大概两周多的时间，总算熬过了最艰难的阶段，Linux开始逐步上手。</p>
<p>从那时开始，每当需要部署什么服务的时候，我的首选操作系统不再是Windows Server，而是Linux。</p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>服务器不需要漂亮的图形界面，不需要花里胡哨的功能，只需要具备最基本的功能、更低的系统资源消耗、更高的效率和稳定性。这些要求，Linux都完美地做到了。如今，Linux在云计算、大数据、嵌入式开发等领域得到了广泛应用。看到这里，你觉得还有不学习Linux的理由吗？</p>
]]></content>
      <categories>
        <category>学渣笔记</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>P1-初识云计算</title>
    <url>/2020/07/09/P1-%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>云计算作为近几年发展非常迅速的技术，已经成为各大应用的一个基础。那什么是云计算呢？</p>
<h1 id="初识云计算"><a href="#初识云计算" class="headerlink" title="初识云计算"></a>初识云计算</h1><h2 id="何为云计算？"><a href="#何为云计算？" class="headerlink" title="何为云计算？"></a>何为云计算？</h2><p>美国国家标准与技术研究院（NIST）对云计算作出了定义：</p>
<blockquote>
<p>云计算是一个模型，这个模型可以方便地按需访问一个可配置的计算资源（例如，网络、服务器、存储设备、应用程序以及服务）的公共集。这些资源可以被迅速供应并释放，使得管理资源的工作量、与服务提供商的交互量减小到最低限度。</p>
</blockquote>
<p>通俗来讲，“云”指的是提供资源的网络，而“计算”则指的是一台或多台性能强大的计算机提供的计算服务（包括各种功能、资源等）。云计算通过网络，将大量的计算资源聚合起来，使用软件进行智能化管理，形成计算资源池，并向广大用户提供计算服务。云计算并非是一种全新的技术，而是一种以互联网为中心的全新的网络应用概念。</p>
<h2 id="云计算的部署模式"><a href="#云计算的部署模式" class="headerlink" title="云计算的部署模式"></a>云计算的部署模式</h2><p>云计算常见的部署模式分为三种，分别是公有云、私有云、混合云。公有云由第三方服务提供商建设，供用户使用；私有云由用户自行建设，即资源建设者=资源使用者；混合云则为私有云和公有云的混合体。而根据层级关系，云计算又分为多种服务模式，如下图：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-07-09-19-04-46.png" alt="2020-07-09-19-04-46"></p>
<ol>
<li><strong>IaaS（Infrastructure as a Service，基础设施即服务）</strong>，把IT基础设施作为服务提供给用户使用，典型代表为云服务器；</li>
<li><strong>PaaS（Platform as a Service，平台即服务）</strong>，把IT基础设施上的平台作为服务提供给用户使用,如阿里云的RDS云数据库等；</li>
<li><strong>SaaS（Software as a Service，软件即服务）</strong>，在IT基础设施的平台上部署应用软件，并将这些应用软件提供给用户使用。常见的SaaS产品有钉钉、企业微信、Office 365等。</li>
</ol>
<h2 id="为何需要云计算？"><a href="#为何需要云计算？" class="headerlink" title="为何需要云计算？"></a>为何需要云计算？</h2><p>云计算具有以下几个明显优势：</p>
<ol>
<li><strong>按需自助服务。</strong> 用户可以按需调配计算资源，例如云服务器使用时长、存储空间大小、网络带宽等性能配置，无需人为与服务提供商进行交互；</li>
<li><strong>广泛的网络接入。</strong> 用户可以通过智能手机、个人电脑等标准的客户端平台，通过网络访问并使用云计算资源。</li>
<li><strong>资源池化。</strong> 云计算使用多租户模型，划分为众多的云资源池，并将资源池分布到多个地域。用户无需知晓资源的具体位置，即可使用云计算资源；</li>
<li><strong>快速弹性伸缩。</strong> 根据用户需求，云计算资源能够被快速、灵活地分配、下发、动态调整、回收；</li>
<li><strong>服务可计量。</strong> 云计算能够根据算法，自动调整、优化云资源（例如CPU、内存、磁盘、带宽等）的使用，并对云资源进行实时监控、记录，为服务提供商和用户提供透明的服务使用状况。</li>
</ol>
]]></content>
      <categories>
        <category>学渣笔记</category>
        <category>华为云</category>
      </categories>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>P2-虚拟化技术概览</title>
    <url>/2020/08/04/P2-%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇文章已经介绍了云计算的一些基础概念，让我们对云计算有了一定的了解。那么，云计算中强大的功能从何而来？它又是如何实现的呢？</p>
<h1 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h1><h2 id="最初印象"><a href="#最初印象" class="headerlink" title="最初印象"></a>最初印象</h2><p>在日常生活中，我们可能已经听说过，或者说已经在使用虚拟化技术了，下图是我们日常使用非常广泛的一个虚拟机软件：VMware Workstation：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-08-04-16-11-10.png" alt="2020-08-04-16-11-10"><br>通俗的讲法就是，虚拟机可以在一台具备操作系统的物理机上，运行一台或多台和物理机一样具有操作系统的虚拟主机。这可能是我们最早对虚拟机的一个理解了。</p>
<h2 id="虚拟化概念"><a href="#虚拟化概念" class="headerlink" title="虚拟化概念"></a>虚拟化概念</h2><p>在虚拟化中，我们需要了解一些重要的概念以及专业术语：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-08-11-15-43-52.png" alt="2020-08-11-15-43-52"><br><strong>OS：</strong>操作系统<br><strong>Guest OS：</strong>虚拟机操作系统<br><strong>Virtual Machine(VM)：</strong>虚拟机<br><strong>Hypervisor：</strong>虚拟化软件层/虚拟机监视器（也称VMM，Virtual Machine Monitor）<br><strong>Host OS：</strong>运行在物理机之上的OS<br><strong>Host Machine：</strong>（主机）物理机</p>
<p>在虚拟化中，OS必不可少。OS是Operating System的缩写，即操作系统。OS具有以下作用：</p>
<ol>
<li>接管硬件；</li>
<li>调度和分配软硬件资源；</li>
<li>为OS软件进行升级、补丁更新；</li>
<li>对主机的生命周期进行管理；</li>
<li>提供人机交互界面；</li>
</ol>
<h2 id="虚拟化特点"><a href="#虚拟化特点" class="headerlink" title="虚拟化特点"></a>虚拟化特点</h2><p><img src="https://cdn.unlinus.cn/hexo-images/2020-08-11-15-30-43.png" alt="2020-08-11-15-30-43"></p>
<ol>
<li><strong>分区：</strong>通过虚拟化技术，对主机资源（计算、存储、网络）进行逻辑划分；</li>
<li><strong>隔离：</strong>虚拟化技术可以保证虚拟机跟虚拟机、虚拟机跟主机进行隔离。例如，某一台虚拟机宕机了或者进程未响应，并不会影响到主机或其他虚拟机的运行；</li>
<li><strong>封装：</strong>虚拟机可以封装为文件，以文件的形式存在，便于虚拟机在不同的主机之间迁移；</li>
<li><strong>独立：</strong>每个虚拟机都是独立个体；</li>
</ol>
<h2 id="虚拟化类型"><a href="#虚拟化类型" class="headerlink" title="虚拟化类型"></a>虚拟化类型</h2><p>根据硬件和虚拟化层的层级关系，虚拟化类型分为以下几种。这里我们来简单介绍一下：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-08-11-15-17-51.png" alt="2020-08-11-15-17-51"></p>
<ol>
<li><strong>I型</strong>：裸金属型虚拟化，直接在硬件上部署Hypervisor，在Hypervisor上运行虚拟机。典型代表有VMware ESXi、Citrix Xen、Hyper-v、KVM、FusionCompute（基于KVM）。I型虚拟化尽可能地使用所有的硬件资源，减少不必要的性能损耗，运行较为稳定。缺点是实现方式较为复杂，需要针对硬件和系统内核进行开发。</li>
<li><strong>II型</strong>：宿主型虚拟化（也可称为寄居虚拟化），在硬件上部署HostOS，在HostOS上部署相关的应用软件实现虚拟化，可以理解为将Hypervisor寄生于HostOS上而实现的虚拟化技术。典型代表有VMware Workstation、VirtualBox。II型虚拟化也是我们日常在Windows平台上使用最广泛的虚拟化类型之一。通常，II型虚拟化是针对OS进行开发的，缺点是额外性能开销大。</li>
<li><strong>操作系统虚拟化（应用级虚拟化）</strong>：一般指的是容器技术，流行的代表有LXC、Docker等；</li>
<li><strong>混合虚拟化</strong>：通过嵌入到系统内核的虚拟化驱动模块，来实现虚拟化，典型代表是KVM。华为FusionCompute就是一套底层基于KVM的虚拟化软件；</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>新手可能会觉得这篇文章非常枯燥无味，这个很正常，本人也是这么熬过来的。毕竟理论是实践的基础，在搞懂了虚拟化的概念后，后续学习将会变得更加顺利。</p>
]]></content>
      <categories>
        <category>学渣笔记</category>
        <category>华为云</category>
      </categories>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>P3-计算虚拟化</title>
    <url>/2020/08/05/P3-%E8%AE%A1%E7%AE%97%E8%99%9A%E6%8B%9F%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文将会在P2的基础上，对云计算中的重要组成部分——计算虚拟化，进行介绍。</p>
<h1 id="计算虚拟化概述"><a href="#计算虚拟化概述" class="headerlink" title="计算虚拟化概述"></a>计算虚拟化概述</h1><p>定义：计算虚拟化通过虚拟化软件层（即Hypervisor或VMM），将物理服务器的硬件资源与上层应用进行解耦，形成统一的资源池，将资源弹性分配给逻辑隔离的虚拟机共享使用。</p>
<h2 id="CPU虚拟化"><a href="#CPU虚拟化" class="headerlink" title="CPU虚拟化"></a>CPU虚拟化</h2><h3 id="CPU特权级别"><a href="#CPU特权级别" class="headerlink" title="CPU特权级别"></a>CPU特权级别</h3><p>在我们的计算机系统中，CPU被划分为几个特权级别，每个级别我们称之为Ring。通过划分Ring级别，可以对CPU进行访问控制。<br><img src="https://cdn.unlinus.cn/hexo-images/2020-08-11-16-35-25.png" alt="2020-08-11-16-35-25"></p>
<ul>
<li><strong>Ring0：</strong>OS内核，处于特权指令级别，安全等级最高，一般只有操作系统才能执行，是内核态；</li>
<li><strong>Ring1/2：</strong>一般驱动程序，处于非特权指令级别；</li>
<li><strong>Ring3：</strong>应用程序，处于非特权指令级别，是用户态；</li>
</ul>
<h3 id="CPU指令"><a href="#CPU指令" class="headerlink" title="CPU指令"></a>CPU指令</h3><p>说到特权级别，不得不提的一点是CPU指令。CPU指令即指挥机器工作的指示和命令，程序就是一系列按一定顺序排列的指令，执行程序的过程就是计算机的工作过程，而指令集就是CPU中用来计算和控制计算机系统的一套指令的集合。目前，CPU指令集分为两大阵营：<a href="https://baike.baidu.com/item/%E7%B2%BE%E7%AE%80%E6%8C%87%E4%BB%A4%E9%9B%86%E8%AE%A1%E7%AE%97%E6%9C%BA/661859?fromtitle=risc&fromid=62696&fr=aladdin">RISC指令集</a>和<a href="https://baike.baidu.com/item/%E5%A4%8D%E6%9D%82%E6%8C%87%E4%BB%A4%E9%9B%86%E8%AE%A1%E7%AE%97%E6%9C%BA/10307148?fromtitle=CISC&fromid=1189443&fr=aladdin">CISC指令集</a>。</p>
<p>根据权限划分的不同，CPU指令又分为以下几种：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-08-11-16-36-18.png" alt="2020-08-11-16-36-18"></p>
<ul>
<li><strong>特权指令：</strong>可以对操作系统产生直接影响的指令，一般不直接提供给给用户使用，例如对系统资源进行管理与分配等；</li>
<li><strong>非特权指令：</strong>一般的用户指令，不会对操作系统产生直接影响；</li>
<li><strong>敏感指令：</strong>指的是操作特权资源的指令，如读写时钟、控制中断、修改内存页表、访问地址重定位系统，以及所有IO指令。个人觉得比较有意思的一点是，在RISC架构的主机中，所有敏感指令都属于特权指令，而在CISC架构中，敏感指令一部分属于特权指令，另一部分属于非特权指令。这将直接影响到虚拟化架构的划分。</li>
</ul>
<h2 id="CPU虚拟化实现方式"><a href="#CPU虚拟化实现方式" class="headerlink" title="CPU虚拟化实现方式"></a>CPU虚拟化实现方式</h2><h3 id="CPU虚拟化历史、架构"><a href="#CPU虚拟化历史、架构" class="headerlink" title="CPU虚拟化历史、架构"></a>CPU虚拟化历史、架构</h3><p>20世纪60年代中期，IBM在自家的大型机上实现了虚拟化技术，主要针对的是自家采用RISC架构的Power系列处理器。虚拟化后，GuestOS会运行在Ring1级别，我们称之为特权解除。此时，GuestOS并不知道自己运行于Hypervisor上，他认为自己是运行在真实硬件上的。所以GuestOS和HostOS一样，是可以在不经过Hypervisor的情况下，将非特权指令直接交由CPU执行的。那么特权指令呢？对于特权指令，Hypervisor会对它进行Trap→模拟后，再交由CPU执行。举个栗子，GuestOS执行了一条特权指令——关机，这条特权指令是敏感指令。Hypervisor捕获到了这条特权敏感指令以后，采取中断→Trap→模拟动作，实际上GuestOS关闭的是它虚拟机本身，而不会是物理主机，这样就保证了物理主机的安全性。</p>
<p>而对于CISC架构的主机来说，RISC的虚拟化方式可能会带来一场灾难，为什么呢？我们知道，在CISC架构里面，敏感指令有一部分是特权指令，另一部分是非特权指令。也就是说，CISC的非特权指令里面，包含有敏感指令。再举个栗子，某天GuestOS执行了一条非特权指令——kill掉一个进程，这条指令是敏感指令，将会直接交给CPU执行。如果这条指令kill掉的是Hypervisor的关键进程，Hypervisor因此宕掉，就会影响到上层的虚拟机。想象一下，生产环境中的Hypervisor出现问题，导致Hypervisor上的所有的业务虚拟机受到牵连，导致业务中断，岂不是会造成重大的损失？</p>
<p>针对以上问题，1999年，VMware推出了针对x86架构主机的虚拟化技术，即全虚拟化方案。</p>
<h3 id="全虚拟化"><a href="#全虚拟化" class="headerlink" title="全虚拟化"></a>全虚拟化</h3><p>全虚拟化场景下，Hypervisor会主动扫描、捕获、翻译来自GuestOS的所有二进制代码，这个过程我们称之为二进制翻译（BT，Binary Translation）。当发现敏感指令和特权指令时，对指令进行二进制翻译后再交由CPU安全执行。然而，这种频繁的动作会加重Hypervisor的工作负担，消耗大量资源，导致性能下降，这是全虚拟化的一大短板。全虚拟化的代表性产品是VMware ESXi、KVM。</p>
<h3 id="半虚拟化（准虚拟化）"><a href="#半虚拟化（准虚拟化）" class="headerlink" title="半虚拟化（准虚拟化）"></a>半虚拟化（准虚拟化）</h3><p>半虚拟化场景下，通过修改GuestOS，令GuestOS得知自己正处于Hypervisor之上。修改后的GuestOS会主动将非特权指令中的敏感指令进行替换,使敏感指令只能够作用于其虚拟机本身，从而防止对HostOS造成影响。此外，GuestOS还会通过Hypercall接口，主动将特权指令发送给Hypervisor，让Hypervisor对来自GuestOS的特权指令进行Trap→模拟后，交由CPU执行。半虚拟化大大减轻了Hypervisor的压力，相比于全虚拟化，半虚拟化性能更高。修改GuestOS的方法通常是在GuestOS中安装半虚拟化驱动。例如，VMware ESXi在GuestOS中部署VMtools、Citrix Xen在GuestOS中部署PV Drivers、QEMU-KVM通过安装virtio驱动，实现半虚拟化。QEMU-KVM半虚拟化会在后续的文章重点介绍。<br><img src="https://cdn.unlinus.cn/hexo-images/2020-08-11-18-50-17.png" alt="2020-08-11-18-50-17"></p>
<h3 id="硬件辅助虚拟化"><a href="#硬件辅助虚拟化" class="headerlink" title="硬件辅助虚拟化"></a>硬件辅助虚拟化</h3><p>目前，硬件辅助虚拟化分为两大阵营：Intel VT-x和AMD-v（SVM），均受到主流的虚拟化产品的支持。<br>以Intel VT-x为例，在硬件辅助虚拟化中，CPU被划分为root（根）模式和none root（非根）模式。虚拟化后，Ring0~3处于none root模式，而Hypervisor处于root模式。也就是说，GuestOS会运行在Ring0级别，这意味着GuestOS执行特权指令时，无需再经过Hypervisor的Hypercall接口进行Trap→模拟。而此时，由于采用了硬件辅助虚拟化技术，CPU能够明确区分来自GuestOS的特权指令和非特权指令，当CPU捕获到来自GuestOS的特权指令和敏感指令时，通过VMCALL调用Hypervisor，Hypervisor令GuestOS自动挂起并切换到Root模式，通过CPU执行特权指令和敏感指令，该过程叫VM Exit。为了让GuestOS执行非特权指令（不包含敏感指令），Hypervisor可以调用VMLaunch或VMResume指令切换到Non-root模式，将GuestOS的指令交由CPU执行，该过程叫VM Entry。AMD-v（SVM）提供的硬件辅助虚拟化功能与Intel VT-x大多相似，但是名称上可能有所出入，此处不作过多介绍。<br>硬件辅助虚拟化既解决了全虚拟化的系统开销与性能损耗，也避免了半虚拟化下修改GuestOS的兼容性问题，进一步解放了GuestOS。<br><img src="https://cdn.unlinus.cn/hexo-images/2020-08-11-18-49-47.png" alt="2020-08-11-18-49-47"></p>
<h1 id="内存虚拟化"><a href="#内存虚拟化" class="headerlink" title="内存虚拟化"></a>内存虚拟化</h1><h2 id="术语和概念"><a href="#术语和概念" class="headerlink" title="术语和概念"></a>术语和概念</h2><ul>
<li>**HPA（Host Physical Address）:**主机物理地址</li>
<li>**HVA（Host Virtual Address）:**主机虚拟地址</li>
<li>**GPA（Guest Physical Address）:**虚拟机物理地址</li>
<li>**GVA（Guest Virtual Address）:**虚拟机虚拟地址</li>
</ul>
<h2 id="内存使用原则"><a href="#内存使用原则" class="headerlink" title="内存使用原则"></a>内存使用原则</h2><p>内存使用时，必须遵循以下原则：</p>
<ul>
<li>使用内存的地址必定从0开始</li>
<li>使用内存的地址必定是连续的</li>
</ul>
<p>OS内核使用内存是从0开始的。一个应用进程使用内存时，也必须是从0开始的。但是多个应用进程需要使用内存时，而内存却只有一个地址0，怎么办呢？</p>
<p>其实，在一个OS里面，每个应用进程都有自己的一小段内存空间，即<strong>虚拟地址空间</strong>，由OS内核维持。而应用进程所使用的内存地址，我们称之为<strong>HVA</strong>。其与<strong>HPA</strong>保持着映射关系，保证每个应用进程都能正常使用内存，如图：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-08-12-13-43-39.png" alt="2020-08-12-13-43-39"><br>通过以上内容我们可以得出结论：一个OS需要使用内存，必须经过物理地址和虚拟地址。</p>
<h2 id="内存虚拟化实现方式"><a href="#内存虚拟化实现方式" class="headerlink" title="内存虚拟化实现方式"></a>内存虚拟化实现方式</h2><p>和物理主机的OS一样，虚拟机的GuestOS需要使用内存，也必须经过物理地址和虚拟地址。而虚拟机的本质是HostOS上的一个进程，在虚拟化环境下，如何解决虚拟机的内存使用问题呢？</p>
<p>这个时候就需要Hypervisor的介入了。Hypervisor在虚拟机和主机之间引入了一层新的地址——<strong>GPA</strong>。Hypervisor将主机非连续的地址映射成了连续的虚拟机物理地址，供虚拟机使用，从而满足了虚拟机使用内存的条件，如图：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-08-12-14-14-11.png" alt="2020-08-12-14-14-11"></p>
<h1 id="I-O虚拟化"><a href="#I-O虚拟化" class="headerlink" title="I/O虚拟化"></a>I/O虚拟化</h1><p>I/O指的是输入/输出设备，相信大家都知道吧！一般来说，我们的硬盘、网卡等设备都属于I/O设备。I/O虚拟化将会在下一篇文章重点介绍。</p>
<h2 id="IO模拟-IO全虚拟化"><a href="#IO模拟-IO全虚拟化" class="headerlink" title="IO模拟(IO全虚拟化)"></a>IO模拟(IO全虚拟化)</h2><p>完全使用Hypervisor来模拟虚拟机的I/O请求，由Hypervisor主动捕获虚拟机的IO操作，然后将捕获的IO操作转发给硬件。这种虚拟化方式不需要对OS和驱动程序进行修改，因此这种方式对于多种虚拟化技术的可移植性和兼容性比较好，但是需要在GuestOS和Hypervisor之间频繁进行交互，性能很差（例如模拟键盘鼠标等常用硬件，通过焦点捕获，焦点被哪个主机捕获就被哪个主机使用）；</p>
<h2 id="IO半虚拟化"><a href="#IO半虚拟化" class="headerlink" title="IO半虚拟化"></a>IO半虚拟化</h2><p>在GuestOS中部署一个前端驱动（也就是上文所讲的半虚拟化驱动），通过前端驱动，将GuestOS的IO请求主动发送给Hypervisor的后端驱动，适用于硬盘和网卡,性能高；</p>
<h2 id="IO-through"><a href="#IO-through" class="headerlink" title="IO-through"></a>IO-through</h2><p>IO设备直通，也就是裸设备映射，直接将物理设备（如硬盘、网卡等）分配给虚拟机，但是需要硬件支持（在Xen下由Dom0分配，但是访问使用直接使用,不经过Dom0，需要硬件支持）。</p>
]]></content>
      <categories>
        <category>学渣笔记</category>
        <category>华为云</category>
      </categories>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>P4-揭秘FusionCompute的核心技术——Xen与KVM</title>
    <url>/2020/08/12/P4-%E6%8F%AD%E7%A7%98FusionCompute%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94Xen%E4%B8%8EKVM/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Xen和KVM都是开源的虚拟化软件，同时它们也是FusionCompute所采用的底层架构。为了方便我们后续对FusionCompute的学习，有必要对Xen和KVM进行初步理解。</p>
<h1 id="Xen-vs-KVM"><a href="#Xen-vs-KVM" class="headerlink" title="Xen vs KVM"></a>Xen vs KVM</h1><h2 id="Xen"><a href="#Xen" class="headerlink" title="Xen"></a>Xen</h2><p>Xen的虚拟化架构如下：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-08-12-15-51-55.png" alt="2020-08-12-15-51-55"><br>在Xen架构中，有两类虚拟机：Domain 0和Domain U。<br><strong>Domain 0：</strong>属于控制域，是一台启动优先级最高、处于特权级别的虚拟机，用于对Domain U进行管理。全虚拟化场景下，Xen负责DomainU的CPU虚拟化和内存虚拟化，而Domain 0的后端驱动会主动捕获Domain U的I/O操作，通过硬件驱动去实现I/O虚拟化。而在半虚拟化场景下，Domain U的前端驱动可以主动将I/O请求发送给Domain 0的后端驱动，Domain 0通过硬件驱动直接访问硬件资源，实现I/O虚拟化。可以这么说，Domain 0全权负责Domian U的I/O虚拟化。<br><strong>Domain U：</strong>普通的用户虚拟机</p>
<h2 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h2><p>KVM，全称Kernel-based Virtual Machine，意为“基于内核的虚拟机”。KVM的虚拟化架构如下：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-08-12-16-24-43.png" alt="2020-08-12-16-24-43"><br>如今，QEMU-KVM一般都会统称为KVM，因为作者已经把QEMU集成到KVM模块中了。其中，QEMU是一个开源的纯虚拟化软件，运行在用户态，主要负责I/O虚拟化。而KVM是一个内核驱动模块，运行在内核态，负责虚拟机的CPU虚拟化和内存虚拟化。</p>
<h1 id="KVM体系架构"><a href="#KVM体系架构" class="headerlink" title="KVM体系架构"></a>KVM体系架构</h1><p>下图是一个基本的KVM体系架构：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-08-12-16-53-27.png" alt="2020-08-12-16-53-27"><br>其中，Libvirt是一个开源的API库，支持C、Python、Go、Java等编程语言。另外，它几乎支持所有主流的虚拟化环境，如VMware ESXi、KVM、Hyper-v、Xen等，在云计算解决方案中使用最为广泛。在KVM中，上层的管理工具都会通过Libvirt，对KVM虚拟化环境进行统一调度、分配。运行时，Libvirt作为一个守护进程驻留在系统后台。</p>
<h2 id="KVM的IO操作流程"><a href="#KVM的IO操作流程" class="headerlink" title="KVM的IO操作流程"></a>KVM的IO操作流程</h2><h3 id="全虚拟化（默认）"><a href="#全虚拟化（默认）" class="headerlink" title="全虚拟化（默认）"></a>全虚拟化（默认）</h3><p><img src="https://cdn.unlinus.cn/hexo-images/2020-08-12-18-02-15.png" alt="2020-08-12-18-02-15"></p>
<ul>
<li>1-2：KVM主动捕获GuestOS的IO请求；</li>
<li>3：KVM模块将GuestOS的IO请求发送到IO共享页，并通知QEMU到IO共享页读取；</li>
<li>4：QEMU收到通知，并从IO共享页读取GuestOS的IO请求；</li>
<li>5-6：QEMU通过设备驱动，将IO请求交由硬件进行模拟执行；</li>
<li>7：执行完毕后，QEMU将IO执行结果返回到到IO共享页，并通知KVM模块到IO共享页进行读取；</li>
<li>8：KVM模块收到通知，并从IO共享页读取GuestOS的IO操作结果；</li>
<li>9-10：KVM模块将IO操作结果返回给GuestOS。</li>
</ul>
<p><strong>缺点：采用同步机制，GuestOS需要主动等待KVM模块将IO共享页中的IO操作结果返回以后，才能继续发送下一条IO操作（即阻塞），性能差。</strong></p>
<h3 id="半虚拟化（使用virtio驱动）"><a href="#半虚拟化（使用virtio驱动）" class="headerlink" title="半虚拟化（使用virtio驱动）"></a>半虚拟化（使用virtio驱动）</h3><p><img src="https://cdn.unlinus.cn/hexo-images/2020-08-12-18-02-32.png" alt="2020-08-12-18-02-32"><br><strong>特点：前端驱动部署在GuestOS上，后端驱动部署在QEMU上。</strong></p>
<ul>
<li>1-2：GuestOS主动将IO请求通过virtio前端驱动发送到virtio-ring（virtio的IO共享环），并通知QEMU到virtio-ring进行捕获；</li>
<li>3：QEMU收到通知，并通过virtio后端驱动从virtio-ring读取GuestOS的IO请求；</li>
<li>4-5：QEMU通过设备驱动，将IO请求交由硬件进行模拟执行；</li>
<li>6：执行完毕后，QEMU将IO执行结果返回到virtio-ring，并通知KVM模块到virtio-ring进行读取；</li>
<li>7：KVM模块收到通知，并从virtio-ring读取GuestOS的IO操作结果；</li>
<li>8：KVM模块将IO操作结果返回给GuestOS。</li>
</ul>
<p><strong>特点：采用异步机制，GuestOS将IO请求批量发送到virtio-ring而无需等待，供QEMU的virtio后端驱动批量读取执行，而GuestOS无需等待执行可以批量从virtio-ring中读取IO操作结果（非阻塞），大幅提升了性能。</strong></p>
]]></content>
      <categories>
        <category>学渣笔记</category>
        <category>华为云</category>
      </categories>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>P6-存储虚拟化</title>
    <url>/2020/08/17/P6-%E5%AD%98%E5%82%A8%E8%99%9A%E6%8B%9F%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>说到存储，可能大多数人首先想到的是硬盘、U盘，然而这些都只是冰山一角。在虚拟化领域，存储是以什么样的形式存在的呢？</p>
<h1 id="存储介质：硬盘"><a href="#存储介质：硬盘" class="headerlink" title="存储介质：硬盘"></a>存储介质：硬盘</h1><p>存储介质种类繁多。在虚拟化领域，硬盘的使用非常广泛，下面会重点介绍硬盘的分类。</p>
<h2 id="根据接口进行划分"><a href="#根据接口进行划分" class="headerlink" title="根据接口进行划分"></a>根据接口进行划分</h2><ol>
<li><p><strong>IDE硬盘：</strong>也称为并口硬盘、ATA硬盘，采用并行传输模式。然而线缆数量过多，难以实现高速率。理论上，提高工作频率可以使传输速率更高，但由于线缆数量多，提高工作频率会导致线路间产生串扰，传输距离变短。目前，这种硬盘已经不再生产，面临淘汰。<br><img src="https://cdn.unlinus.cn/hexo-images/2020-08-23-21-06-00.png" alt="2020-08-23-21-06-00"></p>
</li>
<li><p><strong>SATA硬盘：</strong>也称为串口硬盘，采用串行传输方式，线缆数量少，容易达到较高的传输速率，且传输距离长。SATA硬盘采用了嵌入式时钟信号，能够同时对数据、传输指令进行检查，纠错能力强，可靠性高。SATA硬盘还支持热插拔，维护较为方便。目前，在消费级硬盘领域，SATA硬盘的使用非常广泛。<br><img src="https://cdn.unlinus.cn/hexo-images/2020-08-23-21-06-20.png" alt="2020-08-23-21-06-20"></p>
</li>
<li><p><strong>SAS硬盘：</strong>即串行SCSI硬盘，采用SAS接口。SAS接口是向下兼容SATA接口的，但是和SATA接口不一样的是，它支持串行SCSI协议（SSP）、SCSI管理协议（SSP），且额外提供了冗余传输端口（位于供电接口和数据接口之间的补平部分），可以连接到备用的SAS控制器上，可靠性更高。目前还有一种采用SAS接口、SATA盘体的NL-SAS硬盘，转速较低，但价格比SAS硬盘稍低。SAS硬盘被广泛应用于高可靠性要求的领域，例如服务器。<br><img src="https://cdn.unlinus.cn/hexo-images/2020-08-23-21-07-48.png" alt="2020-08-23-21-07-48"></p>
</li>
</ol>
<h2 id="根据存储构造进行划分"><a href="#根据存储构造进行划分" class="headerlink" title="根据存储构造进行划分"></a>根据存储构造进行划分</h2><ol>
<li><p><strong>HDD：</strong>Hard Disk Driver，即硬盘驱动器，存储单元采用的是机械结构（磁头+磁盘），通过电磁流改变磁盘极性，将数据写到磁盘上，读取数据时采用相反方式。自1973年IBM发明了硬盘以来，机械硬盘的核心结构部分始终没有脱离“温彻斯特”模式：在密封、固定并高速旋转的镀磁盘片的每个盘片上，磁头通过沿盘片径向移动进行数据读写操作。这种磁盘容易实现大容量，且价格较为低廉。缺点是读写速率较低，容易受到外力损坏，且功耗较大。<br><img src="https://cdn.unlinus.cn/hexo-images/2020-08-23-20-54-30.png" alt="2020-08-23-20-54-30"></p>
</li>
<li><p><strong>SSD：</strong>Solid State Drive，即固态驱动器，存储单元采用的是电子结构（NAND Flash芯片），通过在芯片内部进行电子的充电、感应、擦除实现数据读写。SSD在持续写入、随机读写方面性能非常优秀。这种磁盘质量较轻，且功耗低、发热量小，几乎不存在物理损坏，且读写速率高。缺点是使用寿命有限，相对于机械硬盘，SSD价格更高。<br><img src="https://cdn.unlinus.cn/hexo-images/2020-08-23-20-22-03.png" alt="2020-08-23-20-22-03"></p>
</li>
</ol>
<h1 id="常见的三大存储类型"><a href="#常见的三大存储类型" class="headerlink" title="常见的三大存储类型"></a>常见的三大存储类型</h1><h2 id="NAS"><a href="#NAS" class="headerlink" title="NAS"></a>NAS</h2><p><strong>NAS</strong>即Network Attached Storage，网络附加存储，通过网络实现存储空间共享，以文件系统的形式将存储提供给主机使用。NAS为实现共享而生，部署方式简单，扩展性强，且传输距离长。然而其存储性能依赖于存储设备、网络带宽，性能相对较低；<br><img src="https://cdn.unlinus.cn/hexo-images/2020-08-23-21-01-45.png" alt="2020-08-23-21-01-45"></p>
<h2 id="DAS"><a href="#DAS" class="headerlink" title="DAS"></a>DAS</h2><p><strong>DAS</strong>即Direct-attached Storage，直连式存储，与主机总线直连，如硬盘、U盘。这种存储的实现方式最简单，性能比NAS更优。缺点是对主机资源消耗较高，扩展性差（取决于主机存储接口数量），且传输距离有限，不利于共享；<br><img src="https://cdn.unlinus.cn/hexo-images/2020-08-23-21-04-51.png" alt="2020-08-23-21-04-51"></p>
<h2 id="SAN"><a href="#SAN" class="headerlink" title="SAN"></a>SAN</h2><p><strong>SAN</strong>即Storage Area Network，存储区域网络。主机通过交换机和存储设备连接，建立存储网络，以块的形式将存储提供给主机使用。共享，支持距离长，性能高。缺点是构造比较复杂，造价昂贵，通常部署在企业、单位等对存储要求较高的环境。<br><img src="https://cdn.unlinus.cn/hexo-images/2020-08-23-21-03-15.png" alt="2020-08-23-21-03-15"></p>
<p>根据传输介质和传输协议的不同，SAN又分为IP SAN和FC SAN，下图是它们两者之间的区别：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-08-22-22-10-04.png" alt="2020-08-22-22-10-04"></p>
<h1 id="虚拟化存储基础"><a href="#虚拟化存储基础" class="headerlink" title="虚拟化存储基础"></a>虚拟化存储基础</h1><h2 id="磁盘基本概念"><a href="#磁盘基本概念" class="headerlink" title="磁盘基本概念"></a>磁盘基本概念</h2><p><strong>Pool：</strong>存储池，可以看作一个容器，承载的是存储空间；<br><strong>Volume：</strong>卷，是存储系统的内部管理对象，是对存储系统本身而言的；<br><strong>LUN：</strong>逻辑单元号，可以直接映射给主机使用，是Volume对象的对外体现；</p>
<h2 id="虚拟磁盘置备模式"><a href="#虚拟磁盘置备模式" class="headerlink" title="虚拟磁盘置备模式"></a>虚拟磁盘置备模式</h2><p><strong>1. 普通延迟置零：</strong>创建虚拟磁盘后分配空间但不置零，在VM需要对磁盘进行I/O操作时，对虚拟磁盘进行置零，即边写入边置零。这种磁盘性能适中，空间利用率较高，创建时间比较短，适用于一般业务的虚拟机；<br><strong>2. 普通：</strong>创建虚拟磁盘后分配空间并进行置零。这种虚拟磁盘性能最佳，但创建时间也更长，适用于业务繁重、对磁盘I/O要求较高的虚拟机；<br><strong>3. 精简：</strong>在创建虚拟磁盘后，不分配空间也不置零，在VM需要对磁盘进行I/O操作时对虚拟磁盘分配空间、写入数据并置零，即边分配空间边写入边置零。这种磁盘创建时间最短，空间利用率也高，但在虚拟机I/O操作频繁时性能较差，适用于对I/O要求较低的业务虚拟机。</p>
<h2 id="虚拟磁盘模式"><a href="#虚拟磁盘模式" class="headerlink" title="虚拟磁盘模式"></a>虚拟磁盘模式</h2><p><strong>1. 从属：</strong>快照中包含该从属磁盘。<br><strong>2. 独立-持久：</strong>对数据的更改将立即永久写入磁盘。虚拟机创建快照时，不会对该磁盘的数据进行快照，因而不受快照影响。使用快照还原虚拟机时，也不会对该磁盘的数据进行还原。<br><strong>3. 独立-非持久：</strong>虚拟机关闭电源或恢复快照后，对磁盘的更改将被丢弃。</p>
<h2 id="华为虚拟化中的存储模型"><a href="#华为虚拟化中的存储模型" class="headerlink" title="华为虚拟化中的存储模型"></a>华为虚拟化中的存储模型</h2><ol>
<li><strong>存储资源：</strong>指的是物理存储设备，表示存储的位置。例如SAN、NAS、FusionStorage、Advanced SAN；</li>
<li><strong>存储设备：</strong>指的是存储资源中管理单元，表示存储空间。例如LUN、共享目录、存储池、本地磁盘等；</li>
<li><strong>数据存储：</strong>一个可管理、可操作的逻辑管理单元，处于存储设备之上，与存储设备相对应，用于承载虚拟机业务。</li>
</ol>
]]></content>
      <categories>
        <category>学渣笔记</category>
        <category>华为云</category>
      </categories>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>使用CentOS 8 Cockpit+KVM搭建FusionCompute实验环境</title>
    <url>/2020/05/13/%E4%BD%BF%E7%94%A8CentOS%208%20Cockpit+KVM%E6%90%AD%E5%BB%BAFusionCompute%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面已经介绍过如何用闲置台式机来部署FusionCompute了。但是讲真，哪有那么多空闲的机子做这种实验呢？而且我相信大多数人都不会愿意，为了做个实验，把自己的电脑硬掰成一台服务器来用（除了笔者这位傻蛋）。<br>So！笔者以华为官方发布的FusionCompute实验环境搭建方案为参考，在其基础上进行了一些改进，现在决定把这个方案分享给大家。</p>
<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>本文标题或许可以改成《没钱没服务器也能玩转FusionCompute系列》，但是FusionCompute毕竟还是你的大爷，电脑配置不好点的话还是搞不动滴！</p>
<h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><div class="note warning flat"><p><strong>注意</strong><br>FusionCompute要求CPU核心数量（或线程数量）至少要2个以上，内存容量至少8G，磁盘空间至少80GB，这些都是硬性要求。加上本机操作系统和虚拟机的性能损耗，想要把FusionCompute玩起来的话，机子配置至少也得有4核以上的CPU+16G内存，磁盘可用空间大于120GB！</p>
</div>

<table>
<thead>
<tr>
<th>设备</th>
<th>处理器</th>
<th>内存</th>
<th>磁盘</th>
<th>网络</th>
</tr>
</thead>
<tbody><tr>
<td>台式机</td>
<td>AMD-FX8300</td>
<td>杂牌DDR3 1600，8GB+4GB+4GB</td>
<td>杂牌120GB固态，希捷1TB机械盘</td>
<td>1GE网口</td>
</tr>
<tr>
<td>笔记本</td>
<td>Intel i5-8250u</td>
<td>渣士顿DDR4 2400，8GB×2</td>
<td>渣士顿120GB固态，西数500GB机械盘+日立500GB机械盘组RAID 0</td>
<td>1GE网口</td>
</tr>
</tbody></table>
<h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ul>
<li><strong>必备:</strong></li>
</ul>
<ol>
<li>VMware Workstation 15.5</li>
<li>CentOS 8.1.1911系统镜像</li>
<li>XShell 6（虚拟终端软件，用来SSH远程虚拟机）</li>
</ol>
<ul>
<li><strong>华为FusionCompute软件包:</strong></li>
</ul>
<table>
<thead>
<tr>
<th>文件名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>FusionCompute_Installer-6.5.1.zip</td>
<td>FusionCompute安装程序（用于远程部署）</td>
</tr>
<tr>
<td>FusionCompute_6.5.1_CNA.iso</td>
<td>CNA节点安装镜像</td>
</tr>
<tr>
<td>FusionCompute_6.5.1_VRM.iso</td>
<td>VRM节点安装镜像</td>
</tr>
</tbody></table>
<h2 id="网络规划"><a href="#网络规划" class="headerlink" title="网络规划"></a>网络规划</h2><ul>
<li><p>如图（虚拟化层层嵌套，问你怕未！）<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-13-17-14-53.png" alt="2020-05-13-17-14-53"></p>
</li>
<li><p>简化以后其实拓扑就长这样而已：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-13-17-28-26.png" alt="2020-05-13-17-28-26"></p>
</li>
</ul>
<p><strong>思路:</strong> 笔记本用VMware Workstation开一台CentOS 8虚拟机，然后在CentOS 8内安装KVM，在KVM上部署CNA节点。然后，台式机用VMware Workstation开一台虚拟机，专门部署VRM节点。为了保证同网段互通，虚拟机全部采用<strong>桥接模式</strong>。</p>
<h1 id="安装-amp-配置底层操作系统（CentOS-8-1）"><a href="#安装-amp-配置底层操作系统（CentOS-8-1）" class="headerlink" title="安装&amp;配置底层操作系统（CentOS 8.1）"></a>安装&amp;配置底层操作系统（CentOS 8.1）</h1><div class="note warning flat"><p><strong>注意！</strong><br>物理机必须在BIOS内打开处理器虚拟化功能！如果不知道如何操作，请自行百度！</p>
</div>

<p>使用VMware Workstation新建一台虚拟机，配置如下：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-14-03-11-04.png" alt="2020-05-14-03-11-04"></p>
<p>打开虚拟机电源，安装好CentOS 8.1，这个大家应该都会的，不用多说吧！</p>
<div class="note warning flat"><p><strong>注意！</strong><br>为了减少不必要的性能损耗，不需要装GUI！不需要装GUI！不需要装GUI！</p>
</div>
<p><img src="https://cdn.unlinus.cn/hexo-images/2020-05-13-17-35-38.jpg" alt="2020-05-13-17-35-38"><br>安装完成后，使用XShell登录到CentOS 8.1，就可以开始进入以下步骤了。</p>
<h2 id="配置虚拟化环境"><a href="#配置虚拟化环境" class="headerlink" title="配置虚拟化环境"></a>配置虚拟化环境</h2><div class="note warning flat"><p><strong>注意！</strong><br>一定要把VMware Workstation虚拟机的嵌套虚拟化功能打开！如下图：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-13-17-58-44.png" alt="2020-05-13-17-58-44"><br>虚拟机开机后，输入以下命令，根据输出的数值检查系统是否支持虚拟化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">egrep -c &#39;(vmx|svm)&#39; &#x2F;proc&#x2F;cpuinfo</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<p>如果返回数值＞0（返回数值=VMware Workstation为虚拟机分配的vCPU数量），说明系统已经支持虚拟化。</p>
</div>

<p>安装虚拟化环境组（里面包含了libvirt、QEMU-KVM等虚拟化必备组件）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf groupinstall &quot;Virtualization Host&quot;</span><br></pre></td></tr></table></figure>

<p>启动libvirt服务(亲测无需enable，安装完成后已经自动设置为开机启动了)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start libvirtd</span><br></pre></td></tr></table></figure>

<p>输入以下命令，根据输出的数值判断嵌套虚拟化是否已激活：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;sys&#x2F;module&#x2F;kvm_intel&#x2F;parameters&#x2F;nested</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>可见输出结果为0，因为嵌套虚拟化默认情况下是不开启的。我们在<code>/etc/modprobe.d/</code>下新增一个配置文件<code>kvm_intel.conf</code>，加入以下内容，保存并退出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">options kvm-intel nested&#x3D;1</span><br><span class="line">options kvm-intel enable_shadow_vmcs&#x3D;1</span><br><span class="line">options kvm-intel enable_apicv&#x3D;1</span><br><span class="line">options kvm-intel ept&#x3D;1</span><br></pre></td></tr></table></figure>
<p>卸载、重新激活kvm_intel模块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">modprobe -r kvm_intel</span><br><span class="line">modprobe -a kvm_intel</span><br></pre></td></tr></table></figure>
<p>再次检查嵌套虚拟化是否已激活：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-13-18-17-00.png" alt="2020-05-13-18-17-00"></p>
<h2 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h2><div class="note warning flat"><p><strong>注意！</strong><br>Linux网卡名称不是所有人都一样的，别一股脑儿复制粘贴！</p>
</div>
<p>为了保证虚拟机能够正常与外部通信，这里需要配置一个网桥并桥接到外网网卡。网桥可以看成是一台二层交换机，绑定了一个或多个物理网卡（或虚拟网卡），和二层交换机一样具有MAC地址学习、报文转发的功能。网桥配置完成后，主机及连接到该网桥的虚拟机需要与外网通信时，首先会经过该网桥，这就相当于多台电脑连接到一台交换机，通过交换机连接外网进行通信。（如果你熟悉VMware Workstation的桥接网卡，应该也就不难理解了）</p>
<p>首先将原网卡配置文件复制一份并重命名为br0，作为桥接网卡配置文件，然后进行修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts</span><br><span class="line">cp ifcfg-ens32 ifcfg-br0</span><br><span class="line">vim ifcfg-br0</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TYPE&#x3D;Bridge         #将类型Ethernet修改为Bridge，即桥模式</span><br><span class="line">BOOTPROTO&#x3D;static</span><br><span class="line">DEVICE&#x3D;br0          #将设备名更改为br0</span><br><span class="line">ONBOOT&#x3D;yes</span><br><span class="line">IPADDR&#x3D;10.6.0.46</span><br><span class="line">NETMASK&#x3D;255.255.255.0</span><br><span class="line">GATEWAY&#x3D;10.6.0.254</span><br><span class="line">DNS1&#x3D;223.5.5.5  </span><br><span class="line">DNS2&#x3D;119.29.29.29</span><br></pre></td></tr></table></figure>

<p>修改Linux网卡配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens32</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TYPE&#x3D;Ethernet</span><br><span class="line">BOOTPROTO&#x3D;none</span><br><span class="line">DEVICE&#x3D;ens32</span><br><span class="line">ONBOOT&#x3D;yes</span><br><span class="line">BRIDGE&#x3D;br0           #指定网桥，连接到本网卡</span><br></pre></td></tr></table></figure>

<p>修改完成后，保存并退出，然后重新启动网卡：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmcli c reload ens32</span><br></pre></td></tr></table></figure>

<p>使用<code>ip ad</code>查看网络配置信息：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-13-19-52-22.png" alt="2020-05-13-19-52-22"></p>
<h2 id="初次使用Cockpit"><a href="#初次使用Cockpit" class="headerlink" title="初次使用Cockpit"></a>初次使用Cockpit</h2><div class="note info flat"><p><strong>Tips：</strong><br>从CentOS 8开始，系统已经默认内置了Cockpit。Cockpit是一个Web控制台，为用户提供了图形化管理界面，可以实现系统资源监控、添加或删除帐户、电源管理等功能。</p>
</div>
<p>Cockpit默认是处于关闭状态的，我们现在启用Cockpit，并设置为开机自启：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable --now cockpit.socket</span><br></pre></td></tr></table></figure>

<p>关闭防火墙和SELinux（生产环境下不建议这么做）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl disable --now firewalld</span><br><span class="line">sed -i &quot;s&#x2F;enforcing&#x2F;disabled&#x2F;g&quot; &#x2F;etc&#x2F;selinux&#x2F;config</span><br><span class="line">setenforce 0</span><br></pre></td></tr></table></figure>

<p>打开浏览器，输入<code>https://&lt;Linux IP地址&gt;:9090</code>访问Cockpit，使用系统root账号密码进行登录：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-13-18-39-44.png" alt="2020-05-13-18-39-44"><br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-13-18-40-42.png" alt="2020-05-13-18-40-42"></p>
<h1 id="通过Linux-Cockpit部署虚拟机"><a href="#通过Linux-Cockpit部署虚拟机" class="headerlink" title="通过Linux Cockpit部署虚拟机"></a>通过Linux Cockpit部署虚拟机</h1><h2 id="安装虚拟机组件cockpit-machines"><a href="#安装虚拟机组件cockpit-machines" class="headerlink" title="安装虚拟机组件cockpit-machines"></a>安装虚拟机组件cockpit-machines</h2><p>接下来会使用Cockpit来管理KVM虚拟机。安装Cockpit虚拟机组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf install cockpit-machines -y</span><br></pre></td></tr></table></figure>

<p>重启libvirtd服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart libvirtd</span><br></pre></td></tr></table></figure>

<h2 id="创建虚拟机"><a href="#创建虚拟机" class="headerlink" title="创建虚拟机"></a>创建虚拟机</h2><p>登录Cockpit，点击左侧栏“虚拟机”，右侧窗口点击“创建虚拟机”：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-13-20-36-08.png" alt="2020-05-13-20-36-08"></p>
<p>设置虚拟机参数（我已经事先把CNA的安装镜像上传到/opt目录下了）：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-13-22-12-52.png" alt="2020-05-13-22-12-52"></p>
<p>可以看到虚拟机已经成功创建。</p>
<h2 id="配置虚拟机CPU、内存、网络、磁盘等参数"><a href="#配置虚拟机CPU、内存、网络、磁盘等参数" class="headerlink" title="配置虚拟机CPU、内存、网络、磁盘等参数"></a>配置虚拟机CPU、内存、网络、磁盘等参数</h2><p>接下来设置虚拟机CPU参数：</p>
<div class="note warning flat"><p><strong>提示：</strong><br>vCPU数量不要超过6个！FusionCompute基础版免费授权的CPU数量为6个，超过这个限度就等着过期吧！</p>
</div>
<p><img src="https://cdn.unlinus.cn/hexo-images/2020-05-13-20-42-51.png" alt="2020-05-13-20-42-51"><br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-14-13-21-35.png" alt="2020-05-14-13-21-35"></p>
<p>接下来，将VMware Workstation分配给CentOS的256G的虚拟磁盘直通给CNA使用。为什么要用到磁盘直通呢？我们可以看到，部署CNA这台KVM虚拟机经过了2层虚拟化（第一层是VMware Workstation，第二层是QEMU-KVM）。下图表示的是在CentOS内将这块256G磁盘进行格式化，然后在该磁盘上创建一块QCOW2虚拟磁盘供KVM虚拟机使用：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-13-21-42-28.png" alt="2020-05-13-21-42-28"></p>
<p>这样会带来什么问题呢？虽然KVM虚拟机能够正常使用，但是虚拟磁盘经过多层嵌套后，磁盘性能会大打折扣。解决办法就是让KVM虚拟机不经过CentOS的文件系统，直接对这块256GB的磁盘进行读写，也就是磁盘直通，如图：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-13-21-55-02.png" alt="2020-05-13-21-55-02"></p>
<p>配置方法也比较简单，只需要在该虚拟机的配置文件进行修改即可。默认情况下，KVM虚拟机的配置文件保存在<code>/etc/libvirt/qemu/</code>目录下，文件后缀名为.xml。编辑虚拟机配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;libvirt&#x2F;qemu&#x2F;CNA.xml</span><br></pre></td></tr></table></figure>
<div class="note warning flat"><p><strong>注意！</strong><br>根据虚拟机的实际情况进行配置。另外，编辑配置文件的时候一定要注意代码缩进。</p>
</div>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;disk type&#x3D;&#39;block&#39; device&#x3D;&#39;disk&#39;&gt;     &lt;!--磁盘类型为块，设备为磁盘--&gt;</span><br><span class="line">    &lt;driver name&#x3D;&#39;qemu&#39; type&#x3D;&#39;raw&#39;&#x2F;&gt;  &lt;!--驱动器名为qemu，驱动器类型为raw--&gt;</span><br><span class="line">    &lt;source dev&#x3D;&#39;&#x2F;dev&#x2F;sdb&#39;&#x2F;&gt;          &lt;!--源设备，即需要直通的磁盘设备路径--&gt;</span><br><span class="line">    &lt;target dev&#x3D;&#39;sdb&#39; bus&#x3D;&#39;scsi&#39;&#x2F;&gt;</span><br><span class="line">    &lt;!--目标设备，即需要直通的磁盘设备，总线类型根据VMware Workstation创建的磁盘总线类型设置，我的是scsi--&gt;</span><br><span class="line">&lt;&#x2F;disk&gt;</span><br></pre></td></tr></table></figure>
<p>编辑完成后保存并退出，然后使用<code>systemctl restart libvirtd</code>重新启动libvirt服务。回到Cockpit的虚拟机管理界面，我们会发现多了一块磁盘，也就是上述配置的直通磁盘：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-13-22-29-14.png" alt="2020-05-13-22-29-14"></p>
<h2 id="启动虚拟机"><a href="#启动虚拟机" class="headerlink" title="启动虚拟机"></a>启动虚拟机</h2><p>在虚拟机页面处，点击Install开始部署虚拟机，稍等片刻后部署完成，虚拟机会自动打开电源：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-13-22-51-20.png" alt="2020-05-13-22-51-20"><br>看到这个界面，是不是觉得似曾相识？接下来就按照平常安装CNA节点的步骤进行操作就OK了！</p>
<h1 id="开始部署FusionCompute"><a href="#开始部署FusionCompute" class="headerlink" title="开始部署FusionCompute"></a>开始部署FusionCompute</h1><h2 id="安装CNA节点"><a href="#安装CNA节点" class="headerlink" title="安装CNA节点"></a>安装CNA节点</h2><p>设置CNA的网络、主机名、root密码等参数：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-13-22-56-37.png" alt="2020-05-13-22-56-37"><br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-13-22-57-00.png" alt="2020-05-13-22-57-00"><br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-13-22-57-37.png" alt="2020-05-13-22-57-37"><br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-13-22-58-10.png" alt="2020-05-13-22-58-10"><br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-13-22-58-48.png" alt="2020-05-13-22-58-48"></p>
<h2 id="VRM节点配置（踩坑）"><a href="#VRM节点配置（踩坑）" class="headerlink" title="VRM节点配置（踩坑）"></a>VRM节点配置（踩坑）</h2><p>回顾：<a href="https://www.unlinus.cn/2020/05/10/%E5%88%A9%E7%94%A8%E9%97%B2%E7%BD%AE%E4%B8%BB%E6%9C%BA%E6%90%AD%E5%BB%BAFusionCompute%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83/">利用闲置台式机搭建FusionCompute实验环境</a></p>
<h3 id="无法添加主机"><a href="#无法添加主机" class="headerlink" title="无法添加主机"></a>无法添加主机</h3><p>在VRM部署完成以后，创建了集群，但是无法添加主机，出现以下报错：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-13-23-43-30.png" alt="2020-05-13-23-43-30"></p>
<p>解决方法是将CNA节点关机，将虚拟网卡型号改为e1000后重启CNA节点，问题解决！<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-13-23-57-02.png" alt="2020-05-13-23-57-02"><br><strong>PS：千万千万不要手贱去改网卡型号！</strong></p>
<h3 id="虚拟机打开电源失败"><a href="#虚拟机打开电源失败" class="headerlink" title="虚拟机打开电源失败"></a>虚拟机打开电源失败</h3><p>当主机添加完成后，成功创建一台虚拟机，但虚拟机打开电源失败，日志出现以下报错：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-14-02-57-07.png" alt="2020-05-14-02-57-07"></p>
<p>多次修改vCPU核心数、线程数、重新安装CNA，仍然无效。最终解决办法是：关闭CNA节点，修改虚拟机的xml配置文件，修改CPU工作模式，将<code>&lt;cpu mode=&#39;host-model&#39; check=&#39;partical&#39;&gt;</code>修改为<code>&lt;cpu mode=&#39;host-passthrough&#39; check=&#39;none&#39;&gt;</code>，保存退出，重新启动CNA节点后，问题解决：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-14-03-33-24.png" alt="2020-05-14-03-33-24"></p>
<p>后期经过查阅资料得知，<strong>使用host-model模式，Libvirt会根据物理CPU的型号，从规定的CPU中选择一种最接近的CPU型号，而使用host-passthrough模式直接看到的就是物理CPU的型号</strong>。 参考自<a href="https://www.cnblogs.com/uglyliu/p/6066569.html">梦轻尘的博客</a>。</p>
<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>费尽周折，最后总算把实验环境搭起来了。<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-14-03-41-15.png" alt="2020-05-14-03-41-15"><br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-14-03-40-47.png" alt="2020-05-14-03-40-47"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>云计算是离不开Linux的。学习云计算，拥有良好的Linux基础十分重要。</p>
]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
        <tag>华为</tag>
        <tag>云计算</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>利用闲置台式机搭建FusionCompute实验环境</title>
    <url>/2020/05/10/%E5%88%A9%E7%94%A8%E9%97%B2%E7%BD%AE%E4%B8%BB%E6%9C%BA%E6%90%AD%E5%BB%BAFusionCompute%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note info flat"><p><strong>提示</strong><br>本文适合有一定云计算、虚拟化、华为HCIP-CloudComputing基础知识的人群食用。</p>
</div>

<p>FusionCompute是华为基于Linux+KVM研发的一个虚拟化套件，用于实现硬件资源的虚拟化，以及对虚拟化资源进行集中调度和管控，是华为FusionSphere解决方案的重要组成部分之一。为了学习这方面的内容，搭建一个简单可用的FusionSphere实验环境是非常有必要的（为什么我强调可用呢，继续往下看）。</p>
<p>华为已经在去年公布了最新版FusionCompute实验环境的搭建方案，大体思路是：在Ubuntu上部署KVM作为Hypervisor，然后在KVM上搭建FusionCompute。本人有幸在专业实训周对这个方案进行了验证，（当时是在VMware Workstation上安装Ubuntu，在Ubuntu里面安装KVM跑FusionCompute，层层嵌套，电脑配置就4核8G = =），让我彻底明白了原来没有服务器也能学云计算，妈妈再也不用担心我找不到服务器！</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><div class="note warning flat"><p><strong>提示</strong><br>FusionCompute从6.X版本开始，底层架构已经更改为Linux+KVM，不再是Citrix Xen。</p>
</div>

<div class="note danger flat"><p><strong>巨坑</strong><br>经本人多次试验，FusionCompute 6.X可以直接安装在VMware Workstation、Oracle VirtualBox、VMware ESXi等虚拟化软件（平台）上，但是后期没法正常使用（比如：VRM虚拟化部署失败、找不到计算资源等），搭了半天等于白干= =</p>
</div>
<h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><p>用Ubuntu嵌套部署FusionCompute显然是可行的。然而，鉴于其配置过程太过繁琐等原因（本人懒癌晚期/手动滑稽），将FusionCompute部署在物理机上是再简单不过的事情了。以下是本人的实验环境：</p>
<ul>
<li><strong>硬件配置：</strong></li>
</ul>
<table>
<thead>
<tr>
<th>设备</th>
<th>处理器</th>
<th>内存</th>
<th>磁盘</th>
<th>网络</th>
</tr>
</thead>
<tbody><tr>
<td>台式机</td>
<td>AMD-FX8300</td>
<td>杂牌DDR3 1600，8GB+4GB+4GB</td>
<td>杂牌120GB固态，希捷1TB机械盘</td>
<td>1GE网口</td>
</tr>
<tr>
<td>笔记本</td>
<td>Intel i5-8250u</td>
<td>渣士顿DDR4 2400，8GB×2</td>
<td>渣士顿120GB固态，西数500GB机械盘+日立500GB机械盘组RAID 0</td>
<td>1GE网口</td>
</tr>
</tbody></table>
<ul>
<li><strong>新冠时期的实验环境，唉~太难了</strong><br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-12-14-05-54.jpg" alt="2020-05-12-14-05-54"></li>
</ul>
<h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><div class="note info flat"><p><strong>提示</strong><br>本文采用的FusionCompute版本为8.0，最新版。</p>
</div>
<ul>
<li><strong>看表，别看我：</strong></li>
</ul>
<table>
<thead>
<tr>
<th>文件名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>FusionCompute_Installer-8.0.0.zip</td>
<td>FusionCompute安装程序（用于远程部署）</td>
</tr>
<tr>
<td>FusionCompute_CNA-8.0.0-X86_64.iso</td>
<td>CNA节点安装镜像</td>
</tr>
<tr>
<td>FusionCompute_VRM-8.0.0-X86_64.iso</td>
<td>VRM节点安装镜像</td>
</tr>
</tbody></table>
<h2 id="网络规划"><a href="#网络规划" class="headerlink" title="网络规划"></a>网络规划</h2><p>这里我将台式机作为CNA节点，部署FusionCompute(裸机安装)，笔记本利用VMware Workstation创建虚拟机，用来部署VRM节点、IPSAN（因为台式机的机械盘资料太多了不敢乱动…所以这里加一台IPSAN为FFusionCompute提供存储）。因为手头没有光驱，而且这FusionCompute不能用U盘安装，所以CNA节点我会采用PXE部署（把路由器的DHCP服务临时关一下吧，一定要保证本地局域网内没有其他DHCP服务的干扰！）。网络规划如下：</p>
<ul>
<li><strong>拓扑图</strong></li>
</ul>
<p><img src="https://cdn.unlinus.cn/hexo-images/2020-05-10-22-40-36.png" alt="2020-05-10-22-40-36"></p>
<ul>
<li><strong>节点网络配置</strong></li>
</ul>
<table>
<thead>
<tr>
<th>节点名称</th>
<th>说明</th>
<th>节点类型</th>
<th>IP地址</th>
<th>默认网关</th>
</tr>
</thead>
<tbody><tr>
<td>CNA</td>
<td>计算节点代理</td>
<td>物理机，即台式机</td>
<td>10.6.0.10/24</td>
<td>10.6.0.254</td>
</tr>
<tr>
<td>VRM</td>
<td>虚拟化资源管理</td>
<td>虚拟机，部署在笔记本上</td>
<td>10.6.0.60/24</td>
<td>10.6.0.254</td>
</tr>
<tr>
<td>IPSAN</td>
<td>iSCSI服务器</td>
<td>虚拟机，部署在笔记本上</td>
<td>10.6.0.100/24</td>
<td>10.6.0.254</td>
</tr>
</tbody></table>
<h1 id="开始部署FusionCompute"><a href="#开始部署FusionCompute" class="headerlink" title="开始部署FusionCompute"></a>开始部署FusionCompute</h1><h2 id="准备FusionCompute-Installer"><a href="#准备FusionCompute-Installer" class="headerlink" title="准备FusionCompute Installer"></a>准备FusionCompute Installer</h2><p>将FusionCompute Installer解压到文件夹后运行exe安装程序：</p>
<div class="note info flat"><p><strong>纠正</strong><br>计划有变，VRM节点部署在了笔记本的虚拟机上，只勾主机就OK了，VRM不用勾选。</p>
</div>
<p><img src="https://cdn.unlinus.cn/hexo-images/2020-05-10-23-05-27.png" alt="2020-05-10-23-05-27"></p>
<p>实验环境，典型安装即可：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-10-23-06-13.png" alt="2020-05-10-23-06-13"></p>
<p>设置软件包路径，点击浏览，定位到CNA节点安装镜像所在的文件夹，点击开始检测，检查完毕后点击下一步→下一步：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-10-23-09-57.png" alt="2020-05-10-23-09-57"></p>
<h2 id="通过PXE部署CNA节点"><a href="#通过PXE部署CNA节点" class="headerlink" title="通过PXE部署CNA节点"></a>通过PXE部署CNA节点</h2><p>配置DHCP服务等信息，检查无误后点击配置服务（一定要保证本地局域网内没有其他DHCP服务的干扰！一定要保证本地局域网内没有其他DHCP服务的干扰！一定要保证本地局域网内没有其他DHCP服务的干扰！）配置成功后点下一步：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-10-23-11-04.png" alt="2020-05-10-23-11-04"></p>
<p>前片已经配好DHCP服务了，接下来把台式机的电源打开，第一引导设置为PXE（引导模式必须是Legacy！如果不知道怎么设置引导，请自行百度各厂商主板BIOS的设置教程）<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-12-14-06-21.jpg" alt="2020-05-12-14-06-21"></p>
<p>电脑正从PXE开始引导：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-12-14-06-34.jpg" alt="2020-05-12-14-06-34"></p>
<p>稍等片刻后，FusionCompute Installer会发现PXE引导的主机，此时点击开始安装，正式开始部署CNA节点的操作系统。CNA的部署要花几分钟甚至更长时间（得看机子体质如何），请耐心等待：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-10-23-20-30.png" alt="2020-05-10-23-20-30"></p>
<p>当FusionCompute Installer显示的主机安装状态为安装完成时，点击下一步。因为这里实验环境只部署一台CNA，所以这里点确定，进入VRM的安装过程：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-10-23-24-31.png" alt="2020-05-10-23-24-31"></p>
<h2 id="在VMware-Workstation上部署VRM节点"><a href="#在VMware-Workstation上部署VRM节点" class="headerlink" title="在VMware Workstation上部署VRM节点"></a>在VMware Workstation上部署VRM节点</h2><div class="note info flat"><p><strong>提示</strong><br>原计划是将VRM部署在CNA上的，但由于中途出现了一些意外，所以这里直接将VRM安装在笔记本的虚拟机上了。</p>
</div>
<p>使用VMware Workstation创建一台虚拟机并挂载VRM安装镜像，作为VRM节点（性能配置至少4核5GB，硬盘120GB以上）：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-10-23-30-12.png" alt="2020-05-10-23-30-12"></p>
<p>启动虚拟机，引导完成后开始进行各方面配置（使用↑、↓、←、→、Tab、Enter进行选择）：<br>1.配置网络<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-10-23-35-46.png" alt="2020-05-10-23-35-46"></p>
<p><img src="https://cdn.unlinus.cn/hexo-images/2020-05-10-23-35-37.png" alt="2020-05-10-23-35-37"></p>
<p>这里的Default Gateway一定要配！否则跨网段的话无法访问VRM：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-10-23-36-04.png" alt="2020-05-10-23-36-04"></p>
<p>2.root密码配置<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-10-23-36-45.png" alt="2020-05-10-23-36-45"></p>
<p>检查配置，确认无误后点OK，OK，OK…开始安装VRM：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-10-23-36-30.png" alt="2020-05-10-23-36-30"></p>
<p><img src="https://cdn.unlinus.cn/hexo-images/2020-05-10-23-41-50.png" alt="2020-05-10-23-41-50"></p>
<p>#配置FusionCompute</p>
<h2 id="配置VRM"><a href="#配置VRM" class="headerlink" title="配置VRM"></a>配置VRM</h2><h3 id="初次登录"><a href="#初次登录" class="headerlink" title="初次登录"></a>初次登录</h3><p>安装完成后会自动重启。重启完成后稍等片刻，打开浏览器，通过VRM的IP地址访问VRM。初次登录的用户名为admin，密码为IaaS@PORTAL-CLOUD8!（这密码又长又臭= =），且初次登录会要求修改密码（这安全设定可以的，就是有点废手= =）。</p>
<div class="note primary flat"><p><strong>奇淫技巧</strong><br>浏览器按F12，审查密码输入框元素，将onpaste=”return false;”改为onpaste=”return true;”就可以随意粘贴密码了。引自<a href="https://www.txisfine.cn/archives/a66280b7.html">弹霄博科</a>提供的解决方法。</p>
</div>

<p><img src="https://cdn.unlinus.cn/hexo-images/2020-05-10-23-48-39.png" alt="2020-05-10-23-48-39"></p>
<p><img src="https://cdn.unlinus.cn/hexo-images/2020-05-10-23-48-47.png" alt="2020-05-10-23-48-47"></p>
<p>成功登录到VRM：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-10-23-48-55.png" alt="2020-05-10-23-48-55"></p>
<h3 id="创建FusionCompute集群"><a href="#创建FusionCompute集群" class="headerlink" title="创建FusionCompute集群"></a>创建FusionCompute集群</h3><p>展开左侧栏图标，找到资源池，右键单击，创建集群：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-10-23-50-24.png" alt="2020-05-10-23-50-24"></p>
<p>为集群进行一些基础配置：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-10-23-52-41.png" alt="2020-05-10-23-52-41"></p>
<p><img src="https://cdn.unlinus.cn/hexo-images/2020-05-10-23-52-51.png" alt="2020-05-10-23-52-51"></p>
<p><img src="https://cdn.unlinus.cn/hexo-images/2020-05-10-23-53-27.png" alt="2020-05-10-23-53-27"></p>
<p><img src="https://cdn.unlinus.cn/hexo-images/2020-05-10-23-53-36.png" alt="2020-05-10-23-53-36"></p>
<h3 id="为集群添加CNA节点"><a href="#为集群添加CNA节点" class="headerlink" title="为集群添加CNA节点"></a>为集群添加CNA节点</h3><p>右键单击集群，添加主机，输入CNA节点的网络信息：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-10-23-54-26.png" alt="2020-05-10-23-54-26"></p>
<h3 id="为集群添加IPSAN存储"><a href="#为集群添加IPSAN存储" class="headerlink" title="为集群添加IPSAN存储"></a>为集群添加IPSAN存储</h3><div class="note warning flat"><p><strong>提示</strong><br>本文IPSAN节点是在CentOS 7下基于软件实现的，由于内容超出本文范围，IPSAN的安装配置过程这里不一一叙述。</p>
</div>
<p>为集群添加IPSAN存储，首先要添加存储资源。输入IPSAN服务器的IP地址（管理IP和存储IP一致即可），勾选关联主机：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-11-00-00-42.png" alt="2020-05-11-00-00-42"></p>
<p><img src="https://cdn.unlinus.cn/hexo-images/2020-05-11-00-01-06.png" alt="2020-05-11-00-01-06"></p>
<p>在集群内扫描所有存储设备：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-11-00-01-40.png" alt="2020-05-11-00-01-40"></p>
<p>将IPSAN作为数据存储进行添加：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-11-00-01-56.png" alt="2020-05-11-00-01-56"></p>
<p><img src="https://cdn.unlinus.cn/hexo-images/2020-05-11-00-02-08.png" alt="2020-05-11-00-02-08"></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><h2 id="大学时期的实训环境"><a href="#大学时期的实训环境" class="headerlink" title="大学时期的实训环境"></a>大学时期的实训环境</h2><p>怀念那段天天撸服务器撸到爽的日子…<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-12-14-06-57.jpg" alt="2020-05-12-14-06-57"><br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-12-14-07-03.jpg" alt="2020-05-12-14-07-03"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>FusionCompute的部署的方式有好几种，本文介绍的只是万不得已的情况下采用的部署方法，整个部署过程还是比较简单的，当然这个简单是要建立在一定的理论基础和动手实践能力之上的。</p>
<p>只要思想不滑坡，办法总比困难多，HCIE身上纹，掌声送给社会人（假装我有HCIE/狗头保命）。</p>
]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>虚拟化</tag>
        <tag>华为</tag>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>华三服务器·UIS RAID2000 M2（PM8060）阵列卡基本配置</title>
    <url>/2020/07/01/%E5%8D%8E%E4%B8%89%E6%9C%8D%E5%8A%A1%E5%99%A8%C2%B7UIS%20RAID2000%20M2%EF%BC%88PM8060%EF%BC%89%E9%98%B5%E5%88%97%E5%8D%A1%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p><strong>磁盘阵列</strong>（Redundant Arrays of Independent Disks，RAID）是如今大多数服务器的一个基本组成部分，它是由多块独立磁盘组合而成的磁盘组，用于提升整个磁盘系统效能，以及数据的安全性。</p>
</blockquote>
<p>目前实现阵列有两种形式，分为软阵列和硬阵列。软阵列需要通过软件来实现阵列功能，如Windows的RAID5卷、Linux的mdadm工具等。而硬阵列则需要通过硬件来实现，如阵列卡。本文以华三服务器为例的UIS RAID2000 M2（PM8060）阵列卡为例，介绍如何配置一个简单的磁盘阵列。</p>
<h1 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h1><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ol>
<li>服务器：H3C R4900 G2</li>
<li>服务器包含一块UIS RAID2000 M2（PM8060）阵列卡，和3个600GB的SAS磁盘</li>
<li>服务器已启用HDM（华三服务器的BMC）</li>
<li>一台电脑，用于远程操作<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>使用电脑登录到服务器的BMC，点击远程控制台，下载控制台程序并运行（需要安装JRE）：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-07-01-18-10-03.png" alt="2020-07-01-18-10-03"><br>点击控制台左上角的电源，点击开机。如果服务器处于开机状态，则点击重启。等待系统自检通过后（大概需要一分钟），按屏幕提示，按下Esc键或Del键进入BIOS。如下图操作：</li>
</ol>
<p><img src="https://cdn.unlinus.cn/hexo-images/2020-07-01-18-33-03.png" alt="2020-07-01-18-33-03"></p>
<p>选中高级→PMC maxView Storage Manager，一路回车，进入RAID配置界面：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-07-01-18-13-10.png" alt="2020-07-01-18-13-10"></p>
<p><img src="https://cdn.unlinus.cn/hexo-images/2020-07-01-18-16-04.png" alt="2020-07-01-18-16-04"></p>
<p>选中Logical Device Configuration→Create Array，创建一个新的逻辑磁盘组。这里以创建一个RAID1阵列为例：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-07-01-18-19-18.png" alt="2020-07-01-18-19-18"></p>
<p><img src="https://cdn.unlinus.cn/hexo-images/2020-07-01-18-19-43.png" alt="2020-07-01-18-19-43"></p>
<p><img src="https://cdn.unlinus.cn/hexo-images/2020-07-01-18-21-13.png" alt="2020-07-01-18-21-13"><br>ps：由于是实验，这里使用Quick Init（快速部署）即可。</p>
<p>查看配置结果：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-07-01-18-46-38.png" alt="2020-07-01-18-46-38"></p>
]]></content>
      <categories>
        <category>搬砖随记</category>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>RAID</tag>
        <tag>磁盘</tag>
        <tag>BIOS</tag>
      </tags>
  </entry>
  <entry>
    <title>定制属于你的ESXi——为ESXi6.7添加驱动</title>
    <url>/2020/07/04/%E5%AE%9A%E5%88%B6%E5%B1%9E%E4%BA%8E%E4%BD%A0%E7%9A%84ESXi%E2%80%94%E2%80%94%E4%B8%BAESXi6.7%E6%B7%BB%E5%8A%A0%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ESXi是目前企业采用的主流虚拟化方案之一，同时也深受广大极客和发烧友的钟爱。ESXi能够兼容大部分的服务器设备，无需额外安装驱动即可安装运行。但是，某些厂商设备采用了第三方或者自有的配件，而原生ESXi往往没有这些配件的驱动程序，这就会导致ESXi无法识别硬件、安装失败。</p>
<p>早期版本的ESXi（6.5以及更早版本）是可以通过ESXi Customizer来添加第三方驱动程序的，而ESXi6.7已经不再支持用旧版的ESXi Customizer来添加驱动了。So，笔者参照了一下这位大神<a href="https://www.vediotalk.com/archives/2356">Vedio Talk</a>的做法，给大家介绍如何为6.7和更高版本的ESXi添加第三方驱动程序。</p>
<h1 id="进入主题"><a href="#进入主题" class="headerlink" title="进入主题"></a>进入主题</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p><strong>本文使用到的软件如下：</strong></p>
<ol>
<li>ESXi 6.7 u3b离线安装包</li>
<li>ESXi Customizer PS→<a href="http://vibsdepot.v-front.de/tools/ESXi-Customizer-PS-v2.6.0.ps1">点击此处下载</a></li>
<li>PowerShell（Windows 10自带的命令行环境）</li>
<li>硬件的ESXi驱动（本文以H3C服务器的阵列卡驱动为例）</li>
</ol>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="安装Vmware-PowerCLI模块"><a href="#安装Vmware-PowerCLI模块" class="headerlink" title="安装Vmware PowerCLI模块"></a>安装Vmware PowerCLI模块</h3><p>打开Windows PowerShell，输入<code>Install-Module -Name VMware.PowerCLI</code>,在线安装VMware命令行模块（由于是从国外代码库进行下载，此处请自备一杯酸酸乳，不然半年都下不完…）：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-07-04-13-25-37.png" alt="2020-07-04-13-25-37"><br>ps：输入A全部选是</p>
<p>输入<code>set-ExecutionPolicy Bypass</code>，调整PowerShell执行策略，允许运行脚本：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-07-04-13-26-02.png" alt="2020-07-04-13-26-02"></p>
<h3 id="为ESXi添加驱动"><a href="#为ESXi添加驱动" class="headerlink" title="为ESXi添加驱动"></a>为ESXi添加驱动</h3><p><a href="http://vibsdepot.v-front.de/tools/">下载ESXi Customizer PS</a>。将ESXi离线包、驱动程序、ESXi Customizer放到同一个目录，方便操作：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-07-04-14-37-10.png" alt="2020-07-04-14-37-10"></p>
<p>在该目录下，按住Shift键+鼠标右键，在该目录下打开PowerShell：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-07-04-14-38-31.png" alt="2020-07-04-14-38-31"></p>
<p>使用命令，为ESXi包添加驱动。命令格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\ESXi-Customizer-PS-v2.6.0.ps1 -izip &lt;ESXi离线包路径&gt; -pkgDir &lt;驱动文件路径&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.unlinus.cn/hexo-images/2020-07-04-13-30-33.png" alt="2020-07-04-13-30-33"></p>
<p>命令执行完成以后，会在相同目录下生成一个包含驱动的ISO镜像文件。这时我们就可以用这个ISO镜像来安装ESXi了：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-07-04-16-00-08.png" alt="2020-07-04-16-00-08"></p>
<h2 id="另请参阅…"><a href="#另请参阅…" class="headerlink" title="另请参阅…"></a>另请参阅…</h2><ul>
<li>ESXi驱动包下载：<a href="https://vibsdepot.v-front.de/wiki/index.php/List_of_currently_available_ESXi_packages">https://vibsdepot.v-front.de/wiki/index.php/List_of_currently_available_ESXi_packages</a></li>
<li>VMware官方网站：<a href="https://www.vmware.com/">https://www.vmware.com/</a></li>
</ul>
]]></content>
      <categories>
        <category>搬砖随记</category>
        <category>vSphere</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>vSphere</tag>
        <tag>运维</tag>
        <tag>驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>拯救这场灾难——如何解决因误操作导致的VCSA连接丢失</title>
    <url>/2020/05/30/%E6%8B%AF%E6%95%91%E8%BF%99%E5%9C%BA%E7%81%BE%E9%9A%BE%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%9B%A0%E8%AF%AF%E6%93%8D%E4%BD%9C%E5%AF%BC%E8%87%B4%E7%9A%84VCSA%E8%BF%9E%E6%8E%A5%E4%B8%A2%E5%A4%B1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="开始唠嗑…"><a href="#开始唠嗑…" class="headerlink" title="开始唠嗑…"></a>开始唠嗑…</h1><h2 id="因强迫症埋下祸根…"><a href="#因强迫症埋下祸根…" class="headerlink" title="因强迫症埋下祸根…"></a>因强迫症埋下祸根…</h2><p>昨天给部门的vSphere集群配置了分布式交换机（Distribute Switch），把所有虚拟机迁移到分布式端口组上了。好不容易把所有ESXi标准交换机（以下称vswitch0）的端口组删干净了，猛然发现：咋还有残留的端口组捏？！<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-30-17-43-51.png" alt="2020-05-30-17-43-51"><br>明明没有关联虚拟机，删又删不掉，看着又碍眼，干脆另起一个数据数据中心和群集，然后把所有ESXi节点重新转移过去！</p>
<p>然而事实证明这个决定是错误的。当我想把其中一个ESXi节点迁移到新的数据中心和集群时，频繁出现“不支持此操作”“端口20正在使用中”之类的提示。这时才想起，ESXi节点上都运行着Distribute Switch，而且虚拟机都占用着Distribute Switch上的分布式端口组：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-30-17-44-59.png" alt="2020-05-30-17-44-59"><br>重新在vswitch0上创建标准端口组，然后把虚拟机迁移到vswitch0标准端口组，一场灾难从此拉开序幕…</p>
<h2 id="灾难伊始"><a href="#灾难伊始" class="headerlink" title="灾难伊始"></a>灾难伊始</h2><p>一番操作以后，发现VCSA跟所有ESXi节点失去连接了。突然才想起，vswitch0的上行链路不是分配给Distribute Switch了吗？也就是说，此时新建的标准端口组根本就没有上行链路，而VCSA虚拟机恰好在这个ESXi节点上运行……<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-30-16-05-11.png" alt="2020-05-30-16-05-11"></p>
<h1 id="拯救任务开始"><a href="#拯救任务开始" class="headerlink" title="拯救任务开始"></a>拯救任务开始</h1><h2 id="A计划：急速还原"><a href="#A计划：急速还原" class="headerlink" title="A计划：急速还原"></a>A计划：急速还原</h2><p>我还是太年轻了。<br>兴冲冲地登录了ESXi节点，找到VCSA虚拟机，然后编辑设置，把网络调回Distribute Switch的对应端口组，然后发现事情并不简单：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-30-16-11-05.png" alt="2020-05-30-16-11-05"><br>好吧，A计划宣告失败。</p>
<div class="note danger flat"><p><strong>Tips：</strong><br>分布式交换机及其下属端口组只能由VCSA、vCenter进行配置！</p>
</div>

<h2 id="B计划：将计就计"><a href="#B计划：将计就计" class="headerlink" title="B计划：将计就计"></a>B计划：将计就计</h2><p>如果两台虚拟机处于同一个端口组、同一个网段，这两台虚拟机不久可以互访了吗？<br>So，我把ESXi上的一台空闲虚拟机网络适配器分配到和VCSA相同的标准端口组，配好IP，在虚拟机里面打开浏览器，输入VCSA的IP地址：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-30-16-18-39.png" alt="2020-05-30-16-18-39"></p>
<p>emm…再访问底层管理页面（https://&lt;VCSA的IP地址&gt;:5480）看看：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-30-17-42-34.png" alt="2020-05-30-17-42-34"></p>
<p>我很好，只是有点小自闭而已~<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-30-16-21-06.png" alt="2020-05-30-16-21-06"></p>
<h2 id="C计划：重启大法"><a href="#C计划：重启大法" class="headerlink" title="C计划：重启大法"></a>C计划：重启大法</h2><p>软的不行，就来硬的！<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-30-16-26-28.png" alt="2020-05-30-16-26-28"><br>经过漫长的等待（大约过了三四分钟的亚子= =），终于重启完了。考虑到VCSA刚启动不久，可能有一些服务有警告或者根本没启动（汲取上一次事件的经验：戳这儿），于是我先登录到底层管理页面（https://&lt;VCSA的IP地址&gt;:5480）查看VCSA各方面的状态。无奈，还是老样子，登不进去…</p>
<p>So，C计划宣布破产。<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-30-16-34-21.png" alt="2020-05-30-16-34-21"></p>
<h2 id="D计划：另辟蹊径"><a href="#D计划：另辟蹊径" class="headerlink" title="D计划：另辟蹊径"></a>D计划：另辟蹊径</h2><p>我认为VCSA还是得设法连接到外网。<br>突然想起服务器有4个网口，2个被Distribute Switch占用了，剩下两个网口分别连接到两台IPSAN存储，并且有各自的虚拟交换机（vswitch1和vswitch2），其中第4个网口目前没在使用。那我把网口对端的交换机端口调到外网，在vswitch2上新建一个端口组分配给VCSA虚拟机网络适配器，不就可以实现外网访问了吗？</p>
<ul>
<li><p>配置对应的交换机端口为Trunk模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[*CX110-Slot-2X]interface GE 3&#x2F;1&#x2F;2</span><br><span class="line">[*CX110-Slot-2X-GE3&#x2F;1&#x2F;2]port link-type trunk</span><br><span class="line">[*CX110-Slot-2X-GE3&#x2F;1&#x2F;2]port trunk allow-pass vlan all    &#x2F;*临时配置，日常使用不建议允许所有VLAN通过*&#x2F;</span><br><span class="line">[*CX110-Slot-2X-GE3&#x2F;1&#x2F;2]quit</span><br><span class="line">[*CX110-Slot-2X]commit</span><br><span class="line">[~CX110-Slot-2X]</span><br></pre></td></tr></table></figure>
</li>
<li><p>在vswitch2上新建一个端口组:<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-30-16-57-02.png" alt="2020-05-30-16-57-02"></p>
</li>
<li><p>将VCSA的网络划分到该端口组：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-30-16-58-03.png" alt="2020-05-30-16-58-03"></p>
</li>
</ul>
<p>经过以上的轮番骚操作以后，我终于可以放弃跑路的念头了：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-30-17-01-47.png" alt="2020-05-30-17-01-47"></p>
<p>将VCSA虚拟机的网络适配器分配到分布式端口组：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-30-17-32-08.png" alt="2020-05-30-17-32-08"></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><h2 id="教训"><a href="#教训" class="headerlink" title="教训"></a>教训</h2><p>这其实算得上是一次失败的网络割接了。割接前一定要做好万全的准备，包括各种任务计划、风险评估、应急预案等等，而不是说要等到割接过程中出现问题了，才去现场发挥，手忙脚乱，不知所措。</p>
<h2 id="科普"><a href="#科普" class="headerlink" title="科普"></a>科普</h2><p>vSphere标准交换机和分布式交换机的区别：</p>
<ul>
<li><p>标准交换机：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-30-17-36-14.png" alt="2020-05-30-17-36-14"></p>
</li>
<li><p>分布式交换机：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-05-30-17-36-30.png" alt="2020-05-30-17-36-30"></p>
</li>
</ul>
<p>参考链接：<a href="https://blog.51cto.com/13556019/2062018">https://blog.51cto.com/13556019/2062018</a></p>
]]></content>
      <categories>
        <category>搬砖随记</category>
        <category>vSphere</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>vSphere</tag>
        <tag>故障</tag>
        <tag>运维</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>更高的运维格调：Grafana对接Zabbix</title>
    <url>/2020/06/06/%E6%9B%B4%E9%AB%98%E7%9A%84%E8%BF%90%E7%BB%B4%E6%A0%BC%E8%B0%83%EF%BC%9AGrafana%E5%AF%B9%E6%8E%A5Zabbix/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="Grafana——开源、高逼格可视化监控平台！"><a href="#Grafana——开源、高逼格可视化监控平台！" class="headerlink" title="Grafana——开源、高逼格可视化监控平台！"></a>Grafana——开源、高逼格可视化监控平台！</h2><p>搞过运维的应该都听说过Grafana吧！以下这张图就是Grafana的：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-06-06-11-49-01.png" alt="2020-06-06-11-49-01"></p>
<h2 id="再来看看Zabbix"><a href="#再来看看Zabbix" class="headerlink" title="再来看看Zabbix"></a>再来看看Zabbix</h2><p>有人可能问了，Zabbix不是有自带图表吗，为啥还需要Grafana？其实怎么说呢，Zabbix还是偏后端的监控系统，主要面向运维人员。而且，Zabbix图表类型不够丰富，对于一般人来说不太友好。So，我们可以将Grafana与Zabbix对接，作为Zabbix的Dashboard（仪表板），接收来自Zabbix的数据，并通过各种形式的图表展示出来。</p>
<p>废话不多说，开始我的表演。</p>
<h1 id="进入正题"><a href="#进入正题" class="headerlink" title="进入正题"></a>进入正题</h1><h2 id="Grafana安装部署"><a href="#Grafana安装部署" class="headerlink" title="Grafana安装部署"></a>Grafana安装部署</h2><div class="note info flat"><p><strong>注意：</strong></p>
<ol>
<li>本文使用的Linux发行版是CentOS 8.1.1911;</li>
<li>本文使用的Zabbix版本为5.0.1;</li>
<li>本文使用的Grafana版本为7.0.3;</li>
</ol>
</div>
<p>首先，通过dnf安装Grafana：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf install https:&#x2F;&#x2F;dl.grafana.com&#x2F;oss&#x2F;release&#x2F;grafana-7.0.3-1.x86_64.rpm -y</span><br></pre></td></tr></table></figure>

<p>启动Grafana，并设置为开机自启：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable --now grafana-server</span><br></pre></td></tr></table></figure>

<p>打开浏览器，通过<code>http://&lt;Host IP&gt;:3000</code>访问Grafana。Grafana的默认用户名和密码都是admin。初次登录的话，需要修改默认的管理员密码：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-06-06-12-27-06.png" alt="2020-06-06-12-27-06"></p>
<p><img src="https://cdn.unlinus.cn/hexo-images/2020-06-06-12-28-29.png" alt="2020-06-06-12-28-29"></p>
<p><img src="https://cdn.unlinus.cn/hexo-images/2020-06-06-12-28-51.png" alt="2020-06-06-12-28-51"></p>
<h2 id="开始对接Zabbix"><a href="#开始对接Zabbix" class="headerlink" title="开始对接Zabbix"></a>开始对接Zabbix</h2><p>Grafana的插件种类比较丰富，通过Grafana-CLI就能安装各种类型的插件，安装过程比较简单。下面来安装Zabbix插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grafana-cli plugins install alexanderzobnin-zabbix-app </span><br></pre></td></tr></table></figure>
<p>使用<code>systemctl restart grafana-server</code>重新启动Grafana服务。登录Grafana，点击右侧栏设置图标→插件，启用Zabbix插件：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-06-07-10-43-26.png" alt="2020-06-07-10-43-26"><br><img src="https://cdn.unlinus.cn/hexo-images/2020-06-07-10-44-11.png" alt="2020-06-07-10-44-11"></p>
<p>回到首页，添加数据源：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-06-06-15-06-09.png" alt="2020-06-06-15-06-09"></p>
<p>选择刚刚安装的Zabbix插件，进行配置：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-06-06-15-06-53.png" alt="2020-06-06-15-06-53"></p>
<p>配置数据源名称、Zabbix的API URL、Zabbix用户名和密码，随后点击Save&amp;Test保存配置并进行对接测试：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-06-06-15-18-23.png" alt="2020-06-06-15-18-23"></p>
<p>对接成功：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-06-06-15-30-35.png" alt="2020-06-06-15-30-35"></p>
<div class="note danger flat"><p><strong>踩坑：</strong><br>如果Zabbix的版本是5.x以前的，则API URL应该写成这种形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;&lt;Zabbix IP&gt;&#x2F;zabbix&#x2F;api_jsonrpc.php</span><br></pre></td></tr></table></figure></div>

<div class="note warning flat"><p><strong>注意：</strong><br>如果你的Zabbix采用Nginx作为Server，则API URL内的地址需与Nginx配置文件中的server_name一致，否则会造成对接失败：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-06-06-15-29-12.png" alt="2020-06-06-15-29-12"></p>
</div>

<h2 id="创建仪表板并使用Zabbix数据源"><a href="#创建仪表板并使用Zabbix数据源" class="headerlink" title="创建仪表板并使用Zabbix数据源"></a>创建仪表板并使用Zabbix数据源</h2><p>回到Grafana首页，创建一个仪表板：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-06-06-15-40-43.png" alt="2020-06-06-15-40-43"></p>
<p>为仪表板添加一个面板：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-06-06-15-41-46.png" alt="2020-06-06-15-41-46"></p>
<p>设置图表的各项参数，比如数据源、图表类型、图表数据等，设置比较简单且多样化，根据自己需要进行设置就好了：<br>（我的Zabbix已经事先添加了监控主机，所以这里可以直接获取到数据）<br><img src="https://cdn.unlinus.cn/hexo-images/2020-06-06-15-45-40.png" alt="2020-06-06-15-45-40"></p>
<p>点击Apply应用设置，就能看到新建的面板了。点击仪表板右上角的保存图标，保存仪表板：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-06-06-15-55-15.png" alt="2020-06-06-15-55-15"></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>利用Grafana，可以做出各种漂亮的面板、图表，方便我们对数据的解读（最重要的还是逼格高啊/滑稽）。Grafana的可玩性还是比较高的，还有更多的功能需要我们自己去探索。</p>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><ol>
<li>利用Grafana为Zabbix做Dashboard：<a href="https://www.jianshu.com/p/44498cc11a95">https://www.jianshu.com/p/44498cc11a95</a></li>
<li>提升运维格调？Grafana整合Zabbix：<a href="https://mp.weixin.qq.com/s/6GGxZ1vKw9nLiSdWYqtjug">https://mp.weixin.qq.com/s/6GGxZ1vKw9nLiSdWYqtjug</a></li>
</ol>
]]></content>
      <categories>
        <category>搬砖随记</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>运维</tag>
        <tag>Linux</tag>
        <tag>CentOS</tag>
        <tag>监控</tag>
        <tag>高逼格</tag>
      </tags>
  </entry>
  <entry>
    <title>运维利器！使用Kickstart+PXE批量部署Linux操作系统</title>
    <url>/2020/07/06/%E8%BF%90%E7%BB%B4%E5%88%A9%E5%99%A8%EF%BC%81%E4%BD%BF%E7%94%A8Kickstart+PXE%E6%89%B9%E9%87%8F%E9%83%A8%E7%BD%B2Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>相信大家都知道该怎么去安装Linux操作系统了，无非是通过U盘、光驱来安装，家里有矿的伙计已经开始用服务器BMC的远程控制台来安装操作系统了。但是！如果在一个生产环境里面，有成百上千台服务器正等着你去部署操作系统，如果仍然采用以上的方法来部署操作系统，大量重复、繁琐且毫无技术可言的操作将会使你身心疲惫，甚至逐步起了杀心（别问我怎么知道的）。</p>
<p>都0202年了，你们还会用传统方法给生产环境来部署操作系统吗？</p>
<h1 id="关于无人值守安装"><a href="#关于无人值守安装" class="headerlink" title="关于无人值守安装"></a>关于无人值守安装</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>无人值守安装(Unattended Setup)是指软件安装时无需任何用户干预，直接按默认或通过应答文件设置安装，这对于无特殊需求的用户或企业大批量部署安装操作系统及软件时非常方便。<br>——引自<a href="https://baike.baidu.com/item/%E6%97%A0%E4%BA%BA%E5%80%BC%E5%AE%88%E5%AE%89%E8%A3%85/4253153?fr=aladdin">百度百科</a>。</p>
</blockquote>
<p>以前用过Ghost版系统的童鞋应该会知道，在安装Windows时，几乎不需要我们去设置安装系统的各种参数，这其实也算是无人值守安装的一种了。而本文给大家介绍的无人值守安装，是针对一个拥有成百上千台服务器的生产环境而言的，具体介绍请继续往下看。</p>
<h2 id="所需技术"><a href="#所需技术" class="headerlink" title="所需技术"></a>所需技术</h2><p><strong>1. PXE</strong><br>PXE不是一种安装方式，而是一种引导的方式。计算机可以通过PXE，从网络进行操作系统引导。PXE需要配合TFTP和DHCP使用。</p>
<p><strong>2. DHCP</strong><br>DHCP相信大家都不陌生，它的作用是为网络上的每台主机动态分配可用的IP地址。在一个局域网内，两台计算机要实现文件传输，IP地址是必不可少的。这也就不难理解，为何在PXE安装中需要用到DHCP服务了。</p>
<p><strong>3. TFTP</strong><br>同样是文件传输协议，和FTP不一样的是，TFTP免去了用户认证等功能，基于UDP进行文件传输，且不支持交互。在PXE安装时，会自动加载PXE ROM中的TFTP客户端，从远程服务器获取所需的驱动和引导文件。</p>
<h1 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h1><p><strong>实验环境：</strong></p>
<ol>
<li>两台主机，一台作为Server，安装CentOS7；另一台作为Client，不安装操作系统；</li>
<li>CentOS 7安装镜像；</li>
<li>确保两台主机在同一网段，且<strong>必须保证该网段内没有其他DHCP服务器的干扰</strong>！</li>
</ol>
<h2 id="安装配置DHCP服务"><a href="#安装配置DHCP服务" class="headerlink" title="安装配置DHCP服务"></a>安装配置DHCP服务</h2><p>安装DHCP服务：<code>yum install dhcp -y</code><br>编辑DHCP配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/dhcp/dhcpd.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">allow booting;  /*允许引导*/</span><br><span class="line">allow bootp;    /*允许BOOTP协议，使局域网内没有操作系统的主机也能获取IP地址*/</span><br><span class="line">ddns-update-style interim;</span><br><span class="line">ignore client-updates;</span><br><span class="line">subnet 192.168.100.0 netmask 255.255.255.0 &#123;    /*声明一个子网网段*/</span><br><span class="line">        option subnet-mask      255.255.255.0;  /*子网掩码*/</span><br><span class="line">        range dynamic-bootp 192.168.100.101 192.168.100.200;    /*IP地址分配范围*/</span><br><span class="line">        default-lease-time      21600;      /*默认地址租期*/</span><br><span class="line">        max-lease-time          43200;      /*最大地址租期*/</span><br><span class="line">        next-server             192.168.100.100;    /*指定一台PXE引导服务器*/</span><br><span class="line">        filename                <span class="string">&quot;pxelinux.0&quot;</span>;   /*加载引导驱动文件pxelinux.0*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：如果需要跨多个子网分配IP地址，则还需要为网卡添加相应的子网IP，否则DHCP服务器将无法启动！</p>
<h2 id="安装FTP服务"><a href="#安装FTP服务" class="headerlink" title="安装FTP服务"></a>安装FTP服务</h2><p>文章将使用HTTP作为Linux操作系统的安装源。安装Apache：<code>yum install vsftpd -y</code></p>
<p>挂载CentOS7安装镜像到<code>/var/ftp/CentOS_7.2.1511</code>目录下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /var/ftp/CentOS_7.2.1511</span><br><span class="line">mount /dev/sr0 /var/ftp/CentOS_7.2.1511</span><br></pre></td></tr></table></figure>
<p>启动FTP服务,并设置为开机自启：<code>systemctl enable --now vsftpd</code></p>
<h2 id="安装配置TFTP服务"><a href="#安装配置TFTP服务" class="headerlink" title="安装配置TFTP服务"></a>安装配置TFTP服务</h2><p>安装DHCP服务：<code>yum install tftp-server xinetd -y</code><br>编辑TFTP配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/xinetd.d/tftp</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service tftp</span><br><span class="line">&#123;</span><br><span class="line">        socket_type             = dgram</span><br><span class="line">        protocol                = udp</span><br><span class="line">        <span class="built_in">wait</span>                    = yes</span><br><span class="line">        user                    = root</span><br><span class="line">        server                  = /usr/sbin/in.tftpd</span><br><span class="line">        server_args             = -s /var/lib/tftpboot</span><br><span class="line">        <span class="built_in">disable</span>                 = no    /*默认为yes，此处改为no*/</span><br><span class="line">        per_source              = 11</span><br><span class="line">        cps                     = 100 2</span><br><span class="line">        flags                   = IPv4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="准备好引导所需文件"><a href="#准备好引导所需文件" class="headerlink" title="准备好引导所需文件"></a>准备好引导所需文件</h2><h3 id="SYSLinux"><a href="#SYSLinux" class="headerlink" title="SYSLinux"></a>SYSLinux</h3><p>SYSLinux是一个用于提供引导加载的服务程序，此处我们只需用到它里面的引导文件。安装SYSLinux软件包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install syslinux -y</span><br></pre></td></tr></table></figure>

<p>将一些必备的引导文件复制到<code>/var/lib/tftpboot/</code>目录下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp /var/ftp/CentOS_7.2.1511/syslinux/pxelinux.0 /var/lib/tftpboot/</span><br><span class="line">cp /var/ftp/CentOS_7.2.1511/images/pxeboot/&#123;vmlinuz,initrd.img&#125; /var/lib/tftpboot/</span><br><span class="line">cp /var/ftp/CentOS_7.2.1511/isolinux/&#123;vesamenu.c32,boot.msg&#125; /var/lib/tftpboot/</span><br></pre></td></tr></table></figure>

<h3 id="Kickstart自动应答文件"><a href="#Kickstart自动应答文件" class="headerlink" title="Kickstart自动应答文件"></a>Kickstart自动应答文件</h3><p>自动应答文件可以在PXE安装操作系统时，帮助我们自动设置系统安装参数（包括网络配置、磁盘、密码等），减少人机交互。在Linux完成安装后，会在home目录下自动生成一个应答文件anaconda-ks.cfg，我们现在可以将这个应答文件利用起来。将anaconda-ks.cfg复制到<code>/var/ftp/Kickstart/</code>目录下，并重命名为CentOS.cfg：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /var/ftp/kickstart</span><br><span class="line">cp ~/anaconda-ks.cfg /var/ftp/Kickstart/CentOS.cfg</span><br><span class="line">chmod +r /var/ftp/Kickstart/CentOS.cfg  /*赋予执行权限*/</span><br></pre></td></tr></table></figure>
<p>按需修改应答文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /var/ftp/Kickstart/CentOS.cfg</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">url --url=ftp://192.168.100.100/CentOS_7.2.1511    /*默认为CDROM，此处改为FTP安装源路径*/</span><br></pre></td></tr></table></figure>
<div class="note info flat"><p><strong>提示！</strong><br>如果有图形界面，还可以安装system-config-kickstart，来进一步定制Kickstart！</p>
</div>
<h3 id="引导菜单文件"><a href="#引导菜单文件" class="headerlink" title="引导菜单文件"></a>引导菜单文件</h3><p>在tftpboot下新建一个目录pxelinux.cfg（是目录不是文件！）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /var/lib/tftpboot/pxelinux.cfg</span><br></pre></td></tr></table></figure>

<p>将启动菜单配置文件复制到pxelinux.cfg目录下，并重命名为default：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp /var/ftp/CentOS_7.2.1511/isolinux/isolinux.cfg /var/lib/tftpboot/pxelinux.cfg/default</span><br></pre></td></tr></table></figure>

<p>修改启动菜单，将linux作为默认引导项，系统安装形式改为http协议：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /var/lib/tftpboot/pxelinux.cfg/default</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">default linux    /*默认为vesamenu.c32，此处改为linux*/</span><br><span class="line">......</span><br><span class="line">label linux</span><br><span class="line">  menu label ^Install CentOS 7</span><br><span class="line">  kernel vmlinuz</span><br><span class="line">  append initrd=initrd.img inst.stage2=ftp://192.168.100.100/CentOS_7.2.1511/ ks=ftp://192.168.100.100/Kickstart/CentOS.cfg</span><br><span class="line">  /*默认安装源为本地光盘路径。本文安装源使用的是ftp，此处改为安装源的URL*/</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<h2 id="最后阶段"><a href="#最后阶段" class="headerlink" title="最后阶段"></a>最后阶段</h2><p>启动所有服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> --now dhcpd xinetd vsftpd</span><br></pre></td></tr></table></figure>
<p>配置防火墙，放行TFTP、FTP所需端口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=69/udp</span><br><span class="line">firewall-cmd --permanent --add-service=ftp</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>
<p>设置SELinux为宽松模式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setenforce 0</span><br><span class="line">sed -i <span class="string">&#x27;s/enforcing/permissive/g&#x27;</span> /etc/selinux/config</span><br></pre></td></tr></table></figure>

<h1 id="客户机测试"><a href="#客户机测试" class="headerlink" title="客户机测试"></a>客户机测试</h1><p>打开虚拟机电源。由于未安装操作系统，虚拟机将会自动从网络进行引导：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-07-06-15-47-57.png" alt="2020-07-06-15-47-57"></p>
<p><img src="https://cdn.unlinus.cn/hexo-images/2020-07-06-15-48-38.png" alt="2020-07-06-15-48-38"></p>
<p>当出现下图所示界面以后，说明无人值守安装的基本配置已经成功，此时像往常一样进行系统安装操作即可：<br><img src="https://cdn.unlinus.cn/hexo-images/2020-07-06-16-03-02.png" alt="2020-07-06-16-03-02"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文实现的无人值守安装只能算是半自动化部署方式，因为在安装过程中，还需要对安装的主机进行一些参数设置。在实际生产环境下，还需要根据服务器的硬件配置（例如磁盘容量等），来定制应答文件。总之，通过Kickstart+PXE批量部署操作系统，不仅能够将运维人员从重复性的工作中解放出来，还能极大地提升系统安装效率。</p>
]]></content>
      <categories>
        <category>搬砖随记</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>运维</tag>
        <tag>Linux</tag>
        <tag>CentOS</tag>
        <tag>懒人</tag>
      </tags>
  </entry>
</search>
